<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì‚¼êµ­ì§€ íƒ€ì›Œ ë””íœìŠ¤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Malgun Gothic', sans-serif;
            background: #0a0a1a;
            color: white;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        canvas {
            display: block;
            background: #1a1a2e;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .ui-panel {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #ffd700;
        }
        
        .ui-panel h3 {
            font-size: 14px;
            margin-bottom: 5px;
            color: #ffd700;
        }
        
        .ui-panel div {
            font-size: 16px;
            font-weight: bold;
        }
        
        #speedControl {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #ffd700;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
        }
        
        #speedControl h3 {
            font-size: 14px;
            margin: 0;
            color: #ffd700;
        }
        
        .speed-buttons {
            display: flex;
            gap: 5px;
        }
        
        .speed-btn {
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #ffd700;
            color: #ffd700;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .speed-btn:hover {
            background: rgba(255, 215, 0, 0.4);
            transform: scale(1.1);
        }
        
        .speed-btn.active {
            background: #ffd700;
            color: #000;
        }
        
        #speedDisplay {
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
            margin-top: 5px;
        }
        
        #heroSelection {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            z-index: 10;
        }
        
        .hero-btn {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #2a2a4a, #1a1a3a);
            border: 2px solid #555;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            color: white;
            font-size: 12px;
        }
        
        .hero-btn:hover {
            border-color: #ffd700;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        
        .hero-btn.selected {
            border-color: #ffd700;
            background: linear-gradient(135deg, #4a4a6a, #2a2a4a);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }
        
        .hero-btn .cost {
            font-size: 10px;
            color: #ffd700;
            margin-top: 5px;
        }
        
        .tower-slot {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }
        
        .tower-slot.available {
            border-color: rgba(0, 255, 0, 0.5);
            background: rgba(0, 255, 0, 0.1);
        }
        
        .tower-slot.occupied {
            border-color: rgba(255, 0, 0, 0.5);
            background: rgba(255, 0, 0, 0.1);
        }
        
        #skillInfo {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
            padding: 20px 30px;
            border-radius: 15px;
            border: 3px solid #ffd700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.6), inset 0 0 20px rgba(255, 215, 0, 0.1);
            z-index: 10;
            display: none;
            text-align: center;
            min-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        #skillInfo.show {
            display: block;
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }
        
        #skillInfo h4 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 18px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            font-weight: bold;
        }
        
        #skillInfo p {
            color: #fff;
            font-size: 13px;
            margin: 5px 0;
            line-height: 1.4;
        }
        
        .skill-section {
            margin: 15px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }
        
        .skill-section-title {
            color: #ffd700;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: left;
        }
        
        #skillInfo button {
            background: linear-gradient(135deg, #ffd700, #ffaa00);
            color: #000;
            border: 2px solid #ffd700;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 8px;
            font-size: 14px;
            width: 100%;
            transition: all 0.3s;
            box-shadow: 0 4px 10px rgba(255, 215, 0, 0.4);
        }
        
        #skillInfo button:hover:not(:disabled) {
            background: linear-gradient(135deg, #ffed4e, #ffd700);
            transform: scale(1.05);
            box-shadow: 0 6px 15px rgba(255, 215, 0, 0.6);
        }
        
        #skillInfo button:disabled {
            background: linear-gradient(135deg, #444, #333);
            color: #888;
            cursor: not-allowed;
            border-color: #666;
            box-shadow: none;
        }
        
        .gauge-container {
            width: 100%;
            height: 25px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #ffd700;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            margin: 8px 0;
        }
        
        .gauge-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b00, #ffd700, #ff6b00);
            background-size: 200% 100%;
            animation: gaugeGlow 2s linear infinite;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.6);
        }
        
        @keyframes gaugeGlow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }
        
        .gauge-text {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        }
        
        .ultimate-ready {
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 0 40px rgba(255, 215, 0, 0.6);
            }
        }
        
        .skill-cooldown {
            color: #ffaa00;
            font-size: 11px;
            margin-top: 5px;
        }
        
        .skill-ready {
            color: #0f0;
            font-size: 11px;
            margin-top: 5px;
            font-weight: bold;
        }
        
        /* ì¸ë²¤í† ë¦¬ ëª¨ë‹¬ */
        #inventoryModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }
        
        #inventoryModal.show {
            display: flex;
        }
        
        .inventory-container {
            background: linear-gradient(135deg, rgba(20, 20, 40, 0.98), rgba(10, 10, 30, 0.98));
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 30px;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.6);
        }
        
        .inventory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #ffd700;
            padding-bottom: 15px;
        }
        
        .inventory-header h2 {
            color: #ffd700;
            margin: 0;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }
        
        .close-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        .close-btn:hover {
            background: #ff6666;
            transform: scale(1.05);
        }
        
        .inventory-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .equipment-slots {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .equipment-slots h3 {
            color: #ffd700;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .equipment-slot {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 2px solid rgba(255, 215, 0, 0.2);
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .equipment-slot:hover {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            transform: translateX(5px);
        }
        
        .equipment-slot-icon {
            width: 50px;
            height: 50px;
            background: rgba(255, 215, 0, 0.2);
            border: 2px solid #ffd700;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-size: 24px;
        }
        
        .equipment-slot-info {
            flex: 1;
        }
        
        .equipment-slot-name {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .equipment-slot-stats {
            color: #ccc;
            font-size: 12px;
        }
        
        .equipment-slot-empty {
            color: #888;
            font-style: italic;
        }
        
        .inventory-items {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 2px solid rgba(255, 215, 0, 0.3);
        }
        
        .inventory-items h3 {
            color: #ffd700;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .item-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .item-card {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .item-card:hover {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        
        .item-card.equipped {
            border-color: #0f0;
            background: rgba(0, 255, 0, 0.1);
        }
        
        .item-icon {
            font-size: 32px;
            margin-bottom: 5px;
        }
        
        .item-name {
            color: #ffd700;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 3px;
        }
        
        .item-stats {
            color: #aaa;
            font-size: 10px;
        }
        
        .item-rarity-common { border-color: #999; }
        .item-rarity-rare { border-color: #00f; }
        .item-rarity-epic { border-color: #90f; }
        .item-rarity-legendary { border-color: #ff0; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div class="ui-panel">
                <h3>ê¸ˆí™”</h3>
                <div id="gold">500</div>
            </div>
            <div class="ui-panel">
                <h3>ë¼ìš´ë“œ</h3>
                <div id="round">1</div>
            </div>
            <div class="ui-panel">
                <h3>ìƒëª…</h3>
                <div id="lives">20</div>
            </div>
        </div>
        <div id="speedControl">
            <h3>ë°°ì†</h3>
            <div class="speed-buttons">
                <button class="speed-btn" data-speed="0.5">0.5x</button>
                <button class="speed-btn active" data-speed="1">1x</button>
                <button class="speed-btn" data-speed="1.5">1.5x</button>
                <button class="speed-btn" data-speed="2">2x</button>
                <button class="speed-btn" data-speed="3">3x</button>
            </div>
            <div id="speedDisplay">1.0x</div>
        </div>
        <div id="skillInfo">
            <h4 id="skillName">ì˜ì›… ìŠ¤í‚¬</h4>
            
            <div class="skill-section">
                <div class="skill-section-title">ì¼ë°˜ ìŠ¤í‚¬</div>
                <p id="skillDescription">ìŠ¤í‚¬ ì„¤ëª…</p>
                <div id="skillCooldownInfo" class="skill-cooldown"></div>
                <button id="useSkillBtn" onclick="useSelectedHeroSkill()">ìŠ¤í‚¬ ì‚¬ìš©</button>
            </div>
            
            <div class="skill-section">
                <div class="skill-section-title">í•„ì‚´ê¸°</div>
                <p id="ultimateDescription">í•„ì‚´ê¸° ì„¤ëª…</p>
                <div class="gauge-container">
                    <div id="ultimateGauge" class="gauge-fill" style="width: 0%;"></div>
                    <div class="gauge-text">
                        <span id="ultimateGaugeText">0%</span>
                    </div>
                </div>
                <div id="ultimateStatus" style="font-size: 11px; margin-top: 5px;"></div>
                <button id="useUltimateBtn" onclick="useSelectedHeroUltimate()" disabled>í•„ì‚´ê¸° ì‚¬ìš©</button>
            </div>
            <div class="skill-section">
                <button id="openInventoryBtn" onclick="openInventory()" style="background: linear-gradient(135deg, #4a90e2, #357abd); border-color: #4a90e2;">ì¸ë²¤í† ë¦¬ ì—´ê¸°</button>
            </div>
        </div>
        
        <!-- ë³´ìŠ¤ ì¶œí˜„ ì•Œë¦¼ -->
        <div id="bossAlert" class="boss-alert">
            <div class="boss-alert-content">
                <div class="boss-alert-title">ë³´ìŠ¤ ì¶œí˜„!</div>
                <div class="boss-alert-subtitle">ë¼ìš´ë“œ <span id="bossRoundNumber"></span> ë³´ìŠ¤ê°€ ë‚˜íƒ€ë‚¬ìŠµë‹ˆë‹¤!</div>
            </div>
        </div>
        
        <div id="heroSelection">
            <div class="hero-btn" data-hero="0">
                <div>ìœ ë¹„</div>
                <div class="cost">100G</div>
            </div>
            <div class="hero-btn" data-hero="1">
                <div>ê´€ìš°</div>
                <div class="cost">150G</div>
            </div>
            <div class="hero-btn" data-hero="2">
                <div>ì¥ë¹„</div>
                <div class="cost">150G</div>
            </div>
            <div class="hero-btn" data-hero="3">
                <div>ì œê°ˆëŸ‰</div>
                <div class="cost">200G</div>
            </div>
        </div>
        
        <!-- ì¸ë²¤í† ë¦¬ ëª¨ë‹¬ -->
        <div id="inventoryModal">
            <div class="inventory-container">
                <div class="inventory-header">
                    <h2 id="inventoryHeroName">ì˜ì›… ì¸ë²¤í† ë¦¬</h2>
                    <button class="close-btn" onclick="closeInventory()">ë‹«ê¸°</button>
                </div>
                <div class="inventory-content">
                    <div class="equipment-slots">
                        <h3>ì°©ìš© ì¥ë¹„</h3>
                        <div class="equipment-slot" data-slot="weapon" onclick="openItemSelector('weapon')">
                            <div class="equipment-slot-icon">âš”ï¸</div>
                            <div class="equipment-slot-info">
                                <div class="equipment-slot-name">ë¬´ê¸°</div>
                                <div class="equipment-slot-stats" id="weaponSlot">ë¹„ì–´ìˆìŒ</div>
                            </div>
                        </div>
                        <div class="equipment-slot" data-slot="armor" onclick="openItemSelector('armor')">
                            <div class="equipment-slot-icon">ğŸ›¡ï¸</div>
                            <div class="equipment-slot-info">
                                <div class="equipment-slot-name">ê°‘ì˜·</div>
                                <div class="equipment-slot-stats" id="armorSlot">ë¹„ì–´ìˆìŒ</div>
                            </div>
                        </div>
                        <div class="equipment-slot" data-slot="helmet" onclick="openItemSelector('helmet')">
                            <div class="equipment-slot-icon">â›‘ï¸</div>
                            <div class="equipment-slot-info">
                                <div class="equipment-slot-name">íˆ¬êµ¬</div>
                                <div class="equipment-slot-stats" id="helmetSlot">ë¹„ì–´ìˆìŒ</div>
                            </div>
                        </div>
                        <div class="equipment-slot" data-slot="accessory" onclick="openItemSelector('accessory')">
                            <div class="equipment-slot-icon">ğŸ’</div>
                            <div class="equipment-slot-info">
                                <div class="equipment-slot-name">ì¥ì‹ êµ¬</div>
                                <div class="equipment-slot-stats" id="accessorySlot">ë¹„ì–´ìˆìŒ</div>
                            </div>
                        </div>
                    </div>
                    <div class="inventory-items">
                        <h3>ë³´ìœ  ì•„ì´í…œ</h3>
                        <div class="item-list" id="itemList">
                            <!-- ì•„ì´í…œ ëª©ë¡ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ê²Œì„ ë³€ìˆ˜
        let gold = 500;
        let round = 1;
        let lives = 20;
        let placingHeroType = null;
        let selectedHero = null;
        let gameSpeed = 3.0; // ê²Œì„ ë°°ì† (ê¸°ë³¸ 3.0x)
        let bossAlertTimer = 0; // ë³´ìŠ¤ ì¶œí˜„ ì•Œë¦¼ íƒ€ì´ë¨¸
        let showBossAlert = false; // ë³´ìŠ¤ ì¶œí˜„ ì•Œë¦¼ í‘œì‹œ ì—¬ë¶€
        
        // ê²½ë¡œ ìƒì„± í•¨ìˆ˜ (Enemyì™€ ê³µìœ )
        function generatePath() {
            const path = [];
            const startY = canvas.height / 2;
            const segments = 8;
            
            for (let i = 0; i <= segments; i++) {
                const progress = i / segments;
                const x = canvas.width * progress;
                const y = startY + Math.sin(progress * Math.PI * 2) * 150;
                path.push({ x, y });
            }
            
            return path;
        }
        
        // íƒ€ì›Œ ìŠ¬ë¡¯ ìœ„ì¹˜ ìƒì„± í•¨ìˆ˜ (ê²½ë¡œ ê·¼ì²˜ì— ë°°ì¹˜)
        function generateTowerSlots() {
            const slots = [];
            const path = generatePath();
            const pathOffset = 100; // ê²½ë¡œë¡œë¶€í„°ì˜ ê±°ë¦¬
            
            // ê²½ë¡œë¥¼ ë”°ë¼ ì–‘ìª½ì— ìŠ¬ë¡¯ ë°°ì¹˜
            for (let i = 0; i < path.length; i++) {
                const pathPoint = path[i];
                
                // ê²½ë¡œ ìœ„ìª½ ìŠ¬ë¡¯
                slots.push({ x: pathPoint.x, y: pathPoint.y - pathOffset });
                // ê²½ë¡œ ì•„ë˜ìª½ ìŠ¬ë¡¯
                slots.push({ x: pathPoint.x, y: pathPoint.y + pathOffset });
                
                // ê²½ë¡œ ì–‘ìª½ì— ì¶”ê°€ ìŠ¬ë¡¯
                if (i % 2 === 0) {
                    slots.push({ x: pathPoint.x - 60, y: pathPoint.y - pathOffset });
                    slots.push({ x: pathPoint.x + 60, y: pathPoint.y - pathOffset });
                } else {
                    slots.push({ x: pathPoint.x - 60, y: pathPoint.y + pathOffset });
                    slots.push({ x: pathPoint.x + 60, y: pathPoint.y + pathOffset });
                }
            }
            
            return slots;
        }
        
        let towerSlots = [];
        
        // ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // ìº”ë²„ìŠ¤ í¬ê¸° ë³€ê²½ ì‹œ íƒ€ì›Œ ìŠ¬ë¡¯ ì¬ìƒì„±
            towerSlots = generateTowerSlots();
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // ì˜ì›… ì´ë¦„
        const heroNames = ['ìœ ë¹„', 'ê´€ìš°', 'ì¥ë¹„', 'ì œê°ˆëŸ‰'];
        const heroCosts = [100, 150, 150, 200];
        const skillNames = ['íšŒë³µ', 'ì²­ë£¡ì°¸', 'ì¶©ê²©íŒŒ', 'íŒ”ê´˜ì§„'];
        const skillDescriptions = [
            'ìì‹ ì˜ ì²´ë ¥ì„ 50 íšŒë³µí•©ë‹ˆë‹¤',
            'ì „ë°© ì¼ì§ì„ ì˜ ëª¨ë“  ì ì—ê²Œ 3ë°° í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤',
            'ì£¼ë³€ ëª¨ë“  ì ì—ê²Œ 2.5ë°° í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤',
            'ê´‘ì—­ ë²”ìœ„ì˜ ëª¨ë“  ì ì—ê²Œ 2ë°° í”¼í•´ë¥¼ ì…í™ë‹ˆë‹¤'
        ];
        const ultimateNames = ['ì¸ë•', 'ì²­ë£¡ì°¸ ì—°ì†', 'ëŒ€ì§€ ì¶©ê²©íŒŒ', 'ì²œë‘¥ ë²ˆê°œ'];
        const ultimateDescriptions = [
            'ì™„ì „ íšŒë³µ + ê³µê²©ë ¥ 50% ì¦ê°€ + ì£¼ë³€ ì˜ì›… íšŒë³µ',
            'ì „ë°© 300 ë²”ìœ„ì— 3ë²ˆ ì—°ì† 5ë°° í”¼í•´',
            '350 ë²”ìœ„ì˜ ëª¨ë“  ì ì—ê²Œ 6ë°° í”¼í•´',
            '400 ë²”ìœ„ì˜ ëª¨ë“  ì ì—ê²Œ 4ë°° í”¼í•´'
        ];
        
        // ìŠ¤í‚¬ ì‚¬ìš© í•¨ìˆ˜
        function useSelectedHeroSkill() {
            if (selectedHero && selectedHero.canUseSkill()) {
                selectedHero.useSkill(enemies);
                updateSkillInfo();
            }
        }
        
        // ìŠ¤í‚¬ ì •ë³´ ì—…ë°ì´íŠ¸
        function updateSkillInfo() {
            const skillInfo = document.getElementById('skillInfo');
            const skillName = document.getElementById('skillName');
            const skillDescription = document.getElementById('skillDescription');
            const ultimateDescription = document.getElementById('ultimateDescription');
            const useSkillBtn = document.getElementById('useSkillBtn');
            const useUltimateBtn = document.getElementById('useUltimateBtn');
            const ultimateGauge = document.getElementById('ultimateGauge');
            const ultimateGaugeText = document.getElementById('ultimateGaugeText');
            const skillCooldownInfo = document.getElementById('skillCooldownInfo');
            const ultimateStatus = document.getElementById('ultimateStatus');
            
            if (selectedHero) {
                skillInfo.classList.add('show');
                skillName.textContent = `${heroNames[selectedHero.type]} - ìŠ¤í‚¬ ì •ë³´`;
                
                // ì¼ë°˜ ìŠ¤í‚¬ ì •ë³´
                skillDescription.textContent = `${skillNames[selectedHero.type]}: ${skillDescriptions[selectedHero.type]}`;
                useSkillBtn.disabled = !selectedHero.canUseSkill();
                
                if (selectedHero.skillCooldown > 0) {
                    useSkillBtn.textContent = `ì¿¨ë‹¤ìš´: ${Math.ceil(selectedHero.skillCooldown)}ì´ˆ`;
                    skillCooldownInfo.textContent = `ë‚¨ì€ ì‹œê°„: ${Math.ceil(selectedHero.skillCooldown)}ì´ˆ`;
                    skillCooldownInfo.className = 'skill-cooldown';
                    useSkillBtn.style.background = 'linear-gradient(135deg, #444, #333)';
                    useSkillBtn.style.color = '#888';
                } else {
                    useSkillBtn.textContent = 'ìŠ¤í‚¬ ì‚¬ìš©';
                    skillCooldownInfo.textContent = 'ì‚¬ìš© ê°€ëŠ¥';
                    skillCooldownInfo.className = 'skill-ready';
                    useSkillBtn.style.background = 'linear-gradient(135deg, #ffd700, #ffaa00)';
                    useSkillBtn.style.color = '#000';
                }
                
                // í•„ì‚´ê¸° ì •ë³´
                ultimateDescription.textContent = `${ultimateNames[selectedHero.type]}: ${ultimateDescriptions[selectedHero.type]}`;
                
                // í•„ì‚´ê¸° ê²Œì´ì§€ ì—…ë°ì´íŠ¸
                const gaugePercent = Math.min(100, (selectedHero.ultimateGauge / selectedHero.ultimateGaugeMax) * 100);
                ultimateGauge.style.width = gaugePercent + '%';
                ultimateGaugeText.textContent = Math.floor(gaugePercent) + '%';
                
                useUltimateBtn.disabled = !selectedHero.canUseUltimate();
                
                if (selectedHero.canUseUltimate()) {
                    useUltimateBtn.textContent = 'í•„ì‚´ê¸° ì‚¬ìš©!';
                    useUltimateBtn.style.background = 'linear-gradient(135deg, #ff6b00, #ffd700)';
                    useUltimateBtn.style.color = '#000';
                    useUltimateBtn.style.boxShadow = '0 0 20px rgba(255, 215, 0, 0.8)';
                    useUltimateBtn.classList.add('ultimate-ready');
                    ultimateStatus.textContent = 'âœ“ í•„ì‚´ê¸° ì¤€ë¹„ ì™„ë£Œ!';
                    ultimateStatus.style.color = '#0f0';
                    ultimateStatus.style.fontWeight = 'bold';
                } else {
                    useUltimateBtn.textContent = `í•„ì‚´ê¸° ì‚¬ìš© (${Math.floor(gaugePercent)}%)`;
                    useUltimateBtn.style.background = 'linear-gradient(135deg, #444, #333)';
                    useUltimateBtn.style.color = '#888';
                    useUltimateBtn.style.boxShadow = 'none';
                    useUltimateBtn.classList.remove('ultimate-ready');
                    ultimateStatus.textContent = `ê²Œì´ì§€ ì¶©ì „ í•„ìš” (${Math.floor(gaugePercent)}/100)`;
                    ultimateStatus.style.color = '#ffaa00';
                    ultimateStatus.style.fontWeight = 'normal';
                }
            } else {
                skillInfo.classList.remove('show');
            }
        }
        
        // ì˜ì›… í´ë˜ìŠ¤
        class Hero {
            constructor(x, y, type, slotIndex) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.slotIndex = slotIndex;
                this.health = 100;
                this.maxHealth = 100;
                this.attackPower = 20 + type * 10;
                this.attackRange = 150;
                this.attackSpeed = 1.0;
                this.lastAttackTime = 0;
                this.target = null;
                this.attackAnimation = 0; // 0~1 ì‚¬ì´ì˜ ì• ë‹ˆë©”ì´ì…˜ ê°’
                this.idleAnimation = 0; // ëŒ€ê¸° ì• ë‹ˆë©”ì´ì…˜
                this.rotation = 0;
                
                // ìŠ¤í‚¬ ì‹œìŠ¤í…œ
                this.skillCooldown = 0;
                this.skillCooldownMax = [10, 12, 12, 15][type]; // ê° ì˜ì›…ë³„ ìŠ¤í‚¬ ì¿¨ë‹¤ìš´ (ì´ˆ)
                this.skillEffectTimer = 0; // ìŠ¤í‚¬ ì´í™íŠ¸ íƒ€ì´ë¨¸
                this.skillActive = false; // ìŠ¤í‚¬ í™œì„±í™” ì—¬ë¶€
                
                // í•„ì‚´ê¸° ì‹œìŠ¤í…œ
                this.ultimateGauge = 0; // í•„ì‚´ê¸° ê²Œì´ì§€ (0~100)
                this.ultimateGaugeMax = 100;
                this.ultimateEffectTimer = 0; // í•„ì‚´ê¸° ì´í™íŠ¸ íƒ€ì´ë¨¸
                this.ultimateActive = false; // í•„ì‚´ê¸° í™œì„±í™” ì—¬ë¶€
                
                // ì¥ë¹„ ì‹œìŠ¤í…œ
                this.equipment = {
                    weapon: null,
                    armor: null,
                    helmet: null,
                    accessory: null
                };
                
                // ê¸°ë³¸ ëŠ¥ë ¥ì¹˜ ì €ì¥ (ì¥ë¹„ íš¨ê³¼ ê³„ì‚°ìš©)
                this.baseAttackPower = this.attackPower;
                this.baseAttackRange = this.attackRange;
                this.baseAttackSpeed = this.attackSpeed;
                
                // ì¥ë¹„ íš¨ê³¼ ì ìš©
                this.updateEquipmentStats();
            }
            
            updateEquipmentStats() {
                // ê¸°ë³¸ ëŠ¥ë ¥ì¹˜ë¡œ ì´ˆê¸°í™”
                this.attackPower = this.baseAttackPower;
                this.attackRange = this.baseAttackRange;
                this.attackSpeed = this.baseAttackSpeed;
                
                // ì¥ë¹„ íš¨ê³¼ ì ìš©
                for (const slot in this.equipment) {
                    const item = this.equipment[slot];
                    if (item) {
                        if (item.stats.attackPower) this.attackPower += item.stats.attackPower;
                        if (item.stats.attackRange) this.attackRange += item.stats.attackRange;
                        if (item.stats.attackSpeed) this.attackSpeed += item.stats.attackSpeed;
                        if (item.stats.criticalChance) {
                            // ì¹˜ëª…íƒ€ í™•ë¥ ì€ ë³„ë„ë¡œ ê´€ë¦¬ (ì¶”í›„ êµ¬í˜„)
                        }
                    }
                }
            }
            
            equipItem(item) {
                // ê°™ì€ íƒ€ì…ì˜ ì¥ë¹„ê°€ ìˆìœ¼ë©´ í•´ì œ
                if (this.equipment[item.type]) {
                    this.unequipItem(item.type);
                }
                
                this.equipment[item.type] = item;
                this.updateEquipmentStats();
            }
            
            unequipItem(slotType) {
                if (this.equipment[slotType]) {
                    const item = this.equipment[slotType];
                    this.equipment[slotType] = null;
                    this.updateEquipmentStats();
                    return item;
                }
                return null;
            }
            
            canUseSkill() {
                return this.skillCooldown <= 0;
            }
            
            canUseUltimate() {
                return this.ultimateGauge >= this.ultimateGaugeMax;
            }
            
            addUltimateGauge(amount) {
                this.ultimateGauge = Math.min(this.ultimateGaugeMax, this.ultimateGauge + amount);
            }
            
            useUltimate(enemies) {
                if (!this.canUseUltimate()) return;
                
                this.ultimateGauge = 0; // ê²Œì´ì§€ ì†Œëª¨
                this.ultimateEffectTimer = 3.0; // í•„ì‚´ê¸° ì´í™íŠ¸ 3ì´ˆê°„ í‘œì‹œ
                this.ultimateActive = true;
                
                switch(this.type) {
                    case 0: // ìœ ë¹„ - ì¸ë• (ëŒ€ê·œëª¨ íšŒë³µ + ë²„í”„)
                        this.health = this.maxHealth; // ì™„ì „ íšŒë³µ
                        this.attackPower *= 2.0; // ê³µê²©ë ¥ 100% ì¦ê°€ (ì¼ì‹œì )
                        setTimeout(() => {
                            this.attackPower /= 2.0;
                        }, 15000); // 15ì´ˆ í›„ ì›ë˜ëŒ€ë¡œ
                        // ì£¼ë³€ ëª¨ë“  ì˜ì›… íšŒë³µ ë° ë²„í”„
                        for (const hero of heroes) {
                            if (hero === this) continue;
                            const dx = hero.x - this.x;
                            const dy = hero.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist <= 400) {
                                hero.health = Math.min(hero.maxHealth, hero.health + 50);
                                hero.attackPower *= 1.3; // ì£¼ë³€ ì˜ì›… ê³µê²©ë ¥ 30% ì¦ê°€
                                setTimeout(() => {
                                    hero.attackPower /= 1.3;
                                }, 15000);
                            }
                        }
                        break;
                        
                    case 1: // ê´€ìš° - ì²­ë£¡ì°¸ ì—°ì† ê³µê²© (ê±°ëŒ€í•œ ê²€ê¸°)
                        const angle = this.rotation;
                        // 5ë²ˆ ì—°ì† ê³µê²©ìœ¼ë¡œ ì¦ê°€
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                for (const enemy of enemies) {
                                    if (!enemy.alive) continue;
                                    const dx = enemy.x - this.x;
                                    const dy = enemy.y - this.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    const enemyAngle = Math.atan2(dy, dx);
                                    const angleDiff = Math.abs(angle - enemyAngle);
                                    const normalizedDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);
                                    
                                    if (dist <= 500 && normalizedDiff < Math.PI / 3) {
                                        enemy.takeDamage(this.attackPower * 10); // ë°ë¯¸ì§€ 10ë°°ë¡œ ì¦ê°€
                                    }
                                }
                            }, i * 150);
                        }
                        break;
                        
                    case 2: // ì¥ë¹„ - ëŒ€ì§€ ì¶©ê²©íŒŒ (ê±°ëŒ€í•œ ì¶©ê²©íŒŒ)
                        // ë§¤ìš° ë„“ì€ ë²”ìœ„ì˜ ê°•ë ¥í•œ ì¶©ê²©íŒŒ
                        for (const enemy of enemies) {
                            if (!enemy.alive) continue;
                            const dx = enemy.x - this.x;
                            const dy = enemy.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist <= 500) {
                                enemy.takeDamage(this.attackPower * 12); // ë°ë¯¸ì§€ 12ë°°ë¡œ ì¦ê°€
                            }
                        }
                        break;
                        
                    case 3: // ì œê°ˆëŸ‰ - ì²œë‘¥ ë²ˆê°œ ì†Œí™˜ (í™”ë©´ ì „ì²´ ë²ˆê°œ)
                        // í™”ë©´ ì „ì²´ì— ë²ˆê°œ ê³µê²© (ì—¬ëŸ¬ ë²ˆ íƒ€ê²©)
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => {
                                for (const enemy of enemies) {
                                    if (!enemy.alive) continue;
                                    const dx = enemy.x - this.x;
                                    const dy = enemy.y - this.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (dist <= 600) {
                                        enemy.takeDamage(this.attackPower * 8); // ë°ë¯¸ì§€ 8ë°°ë¡œ ì¦ê°€
                                    }
                                }
                            }, i * 300);
                        }
                        break;
                }
            }
            
            useSkill(enemies) {
                if (!this.canUseSkill()) return;
                
                this.skillCooldown = this.skillCooldownMax;
                this.skillEffectTimer = 1.0; // ìŠ¤í‚¬ ì´í™íŠ¸ 1ì´ˆê°„ í‘œì‹œ
                this.skillActive = true;
                
                switch(this.type) {
                    case 0: // ìœ ë¹„ - íšŒë³µ ìŠ¤í‚¬
                        this.health = Math.min(this.maxHealth, this.health + 50);
                        break;
                        
                    case 1: // ê´€ìš° - ì „ë°© ì¼ì§ì„  ê³µê²©
                        const angle = this.rotation;
                        for (const enemy of enemies) {
                            if (!enemy.alive) continue;
                            const dx = enemy.x - this.x;
                            const dy = enemy.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const enemyAngle = Math.atan2(dy, dx);
                            const angleDiff = Math.abs(angle - enemyAngle);
                            const normalizedDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);
                            
                            if (dist <= 200 && normalizedDiff < Math.PI / 6) {
                                enemy.takeDamage(this.attackPower * 3);
                            }
                        }
                        break;
                        
                    case 2: // ì¥ë¹„ - ê´‘ì—­ ì¶©ê²©íŒŒ
                        for (const enemy of enemies) {
                            if (!enemy.alive) continue;
                            const dx = enemy.x - this.x;
                            const dy = enemy.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist <= 180) {
                                enemy.takeDamage(this.attackPower * 2.5);
                            }
                        }
                        break;
                        
                    case 3: // ì œê°ˆëŸ‰ - ê´‘ì—­ ë§ˆë²• ê³µê²©
                        for (const enemy of enemies) {
                            if (!enemy.alive) continue;
                            const dx = enemy.x - this.x;
                            const dy = enemy.y - this.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist <= 250) {
                                enemy.takeDamage(this.attackPower * 2);
                            }
                        }
                        break;
                }
            }
            
            update(dt, enemies) {
                // ëŒ€ê¸° ì• ë‹ˆë©”ì´ì…˜
                this.idleAnimation += dt * 2;
                
                // ê³µê²© ì• ë‹ˆë©”ì´ì…˜ ê°ì†Œ
                if (this.attackAnimation > 0) {
                    this.attackAnimation = Math.max(0, this.attackAnimation - dt * 5);
                }
                
                // ê°€ì¥ ê°€ê¹Œìš´ ì  ì°¾ê¸°
                let nearestEnemy = null;
                let nearestDist = this.attackRange;
                
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                }
                
                this.target = nearestEnemy;
                
                // íƒ€ê²Ÿì´ ìˆìœ¼ë©´ ë°©í–¥ íšŒì „
                if (this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    this.rotation = Math.atan2(dy, dx);
                    
                    // ê³µê²© (ë°°ì† ì ìš©)
                    const currentTime = Date.now();
                    const attackCooldown = 1000 / (this.attackSpeed * gameSpeed);
                    if (currentTime - this.lastAttackTime > attackCooldown) {
                        this.attack(this.target);
                        this.lastAttackTime = currentTime;
                        this.attackAnimation = 1.0; // ê³µê²© ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘
                    }
                }
            }
            
            attack(enemy) {
                enemy.takeDamage(this.attackPower);
                // ì  ì²˜ì¹˜ ì‹œ í•„ì‚´ê¸° ê²Œì´ì§€ ì¶©ì „
                if (enemy.health <= this.attackPower) {
                    this.addUltimateGauge(2); // ì  ì²˜ì¹˜ ì‹œ 2% ì¶©ì „
                } else {
                    this.addUltimateGauge(1); // ê³µê²© ì‹œ 1% ì¶©ì „
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                const size = 30;
                const idleOffset = Math.sin(this.idleAnimation) * 3;
                const attackOffset = this.attackAnimation * 10;
                
                // ê·¸ë¦¼ì
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(0, size + 5 + idleOffset, size * 0.8, size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ëª¸ì²´ (ëŒ€ê¸° ì• ë‹ˆë©”ì´ì…˜)
                ctx.translate(0, -idleOffset);
                
                // ê³µê²© ëª¨ì…˜ (ì•ìœ¼ë¡œ ë°€ê¸°)
                ctx.translate(-attackOffset * Math.cos(this.rotation), -attackOffset * Math.sin(this.rotation));
                
                // ì˜ì›… íƒ€ì…ë³„ ê·¸ë¦¬ê¸°
                this.drawHeroType(size);
                
                ctx.restore();
                
                // ê³µê²© ë²”ìœ„ í‘œì‹œ (ì„ íƒëœ ê²½ìš°)
                if (selectedHero === this) {
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.attackRange, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // ìŠ¤í‚¬ ì´í™íŠ¸ ê·¸ë¦¬ê¸°
                this.drawSkillEffect();
                
                // í•„ì‚´ê¸° ì´í™íŠ¸ ê·¸ë¦¬ê¸°
                this.drawUltimateEffect();
                
                // ì²´ë ¥ë°”
                const barWidth = size * 2;
                const barHeight = 4;
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - barWidth / 2, this.y - size - 15, barWidth, barHeight);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(this.x - barWidth / 2, this.y - size - 15, barWidth * (this.health / this.maxHealth), barHeight);
                
                // ìŠ¤í‚¬ ì¿¨ë‹¤ìš´ í‘œì‹œ
                if (this.skillCooldown > 0) {
                    const cooldownBarHeight = 3;
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.x - barWidth / 2, this.y + size + 5, barWidth, cooldownBarHeight);
                    ctx.fillStyle = '#ff0';
                    ctx.fillRect(this.x - barWidth / 2, this.y + size + 5, barWidth * (1 - this.skillCooldown / this.skillCooldownMax), cooldownBarHeight);
                    
                    // ì¿¨ë‹¤ìš´ ì‹œê°„ í…ìŠ¤íŠ¸
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(Math.ceil(this.skillCooldown).toString(), this.x, this.y + size + 8);
                } else if (selectedHero === this) {
                    // ìŠ¤í‚¬ ì‚¬ìš© ê°€ëŠ¥ í‘œì‹œ
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                    ctx.fillRect(this.x - barWidth / 2, this.y + size + 5, barWidth, 3);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ìŠ¤í‚¬ ì¤€ë¹„', this.x, this.y + size + 8);
                }
            }
            
            drawSkillEffect() {
                if (!this.skillActive || this.skillEffectTimer <= 0) return;
                
                const progress = 1 - this.skillEffectTimer;
                
                switch(this.type) {
                    case 0: // ìœ ë¹„ - íšŒë³µ ì´í™íŠ¸
                        ctx.fillStyle = `rgba(0, 255, 0, ${0.5 * (1 - progress)})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 40 * progress, 0, Math.PI * 2);
                        ctx.fill();
                        // íšŒë³µ í…ìŠ¤íŠ¸
                        ctx.fillStyle = '#0f0';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('+50', this.x, this.y - 30 - progress * 20);
                        break;
                        
                    case 1: // ê´€ìš° - ì¼ì§ì„  ê²€ê¸°
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.rotation);
                        ctx.strokeStyle = `rgba(0, 255, 0, ${0.8 * (1 - progress)})`;
                        ctx.lineWidth = 8;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(200 * progress, 0);
                        ctx.stroke();
                        // ê²€ê¸° íŒŒí‹°í´
                        for (let i = 0; i < 5; i++) {
                            const offset = (i / 5) * 200 * progress;
                            ctx.fillStyle = `rgba(0, 255, 0, ${0.6 * (1 - progress)})`;
                            ctx.beginPath();
                            ctx.arc(offset, Math.sin(progress * Math.PI * 10 + i) * 10, 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.restore();
                        break;
                        
                    case 2: // ì¥ë¹„ - ì¶©ê²©íŒŒ
                        const shockwaveRadius = 180 * progress;
                        ctx.strokeStyle = `rgba(255, 0, 0, ${0.7 * (1 - progress)})`;
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, shockwaveRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        // ì¶©ê²©íŒŒ íŒŒí‹°í´
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const px = this.x + Math.cos(angle) * shockwaveRadius;
                            const py = this.y + Math.sin(angle) * shockwaveRadius;
                            ctx.fillStyle = `rgba(255, 100, 0, ${0.8 * (1 - progress)})`;
                            ctx.beginPath();
                            ctx.arc(px, py, 8, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 3: // ì œê°ˆëŸ‰ - ë§ˆë²• ì›
                        const magicRadius = 250 * progress;
                        ctx.fillStyle = `rgba(255, 255, 0, ${0.4 * (1 - progress)})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, magicRadius, 0, Math.PI * 2);
                        ctx.fill();
                        // ë§ˆë²• ì› í…Œë‘ë¦¬
                        ctx.strokeStyle = `rgba(255, 255, 0, ${0.8 * (1 - progress)})`;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, magicRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        // ë³„ ëª¨ì–‘ íŒŒí‹°í´
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2;
                            const px = this.x + Math.cos(angle) * magicRadius * 0.7;
                            const py = this.y + Math.sin(angle) * magicRadius * 0.7;
                            ctx.fillStyle = `rgba(255, 255, 0, ${0.9 * (1 - progress)})`;
                            ctx.beginPath();
                            for (let j = 0; j < 5; j++) {
                                const starAngle = (j * Math.PI * 2 / 5) - Math.PI / 2;
                                const sx = px + Math.cos(starAngle) * 8;
                                const sy = py + Math.sin(starAngle) * 8;
                                if (j === 0) ctx.moveTo(sx, sy);
                                else ctx.lineTo(sx, sy);
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                        break;
                }
            }
            
            drawUltimateEffect() {
                if (!this.ultimateActive || this.ultimateEffectTimer <= 0) return;
                const progress = 1 - (this.ultimateEffectTimer / 3.0);
                const time = 3.0 - this.ultimateEffectTimer;
                
                switch(this.type) {
                    case 0: // ìœ ë¹„ - ì¸ë• (í™©ê¸ˆ ë¹›ì˜ ëŒ€í­ë°œ)
                        // ì—¬ëŸ¬ ê²¹ì˜ í™©ê¸ˆ ì›í˜• ì´í™íŠ¸
                        for (let i = 0; i < 5; i++) {
                            const radius = (80 + i * 40) * progress;
                            const alpha = (1 - progress) * (0.7 - i * 0.1);
                            ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        // ë³„ ëª¨ì–‘ íŒŒí‹°í´ (ë” ë§ì´)
                        for (let i = 0; i < 16; i++) {
                            const angle = (i / 16) * Math.PI * 2 + progress * Math.PI * 4;
                            const dist = 100 * progress;
                            const px = this.x + Math.cos(angle) * dist;
                            const py = this.y + Math.sin(angle) * dist;
                            ctx.fillStyle = `rgba(255, 215, 0, ${(1 - progress) * 0.9})`;
                            ctx.beginPath();
                            for (let j = 0; j < 5; j++) {
                                const starAngle = (j * Math.PI * 2 / 5) - Math.PI / 2;
                                const sx = px + Math.cos(starAngle) * 15;
                                const sy = py + Math.sin(starAngle) * 15;
                                if (j === 0) ctx.moveTo(sx, sy);
                                else ctx.lineTo(sx, sy);
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                        // ì¤‘ì•™ ë¹›ë‚˜ëŠ” íš¨ê³¼
                        ctx.fillStyle = `rgba(255, 255, 200, ${(1 - progress) * 0.8})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 60 * progress, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 1: // ê´€ìš° - ì²­ë£¡ì°¸ ì—°ì† (ê±°ëŒ€í•œ ë…¹ìƒ‰ ê²€ê¸°)
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.rotate(this.rotation);
                        // ê±°ëŒ€í•œ ê²€ê¸° 5ê°œ (ë” í¬ê³  í™”ë ¤í•˜ê²Œ)
                        for (let i = 0; i < 5; i++) {
                            const offset = i * 120 * progress;
                            const waveOffset = Math.sin(time * 5 + i) * 20;
                            ctx.strokeStyle = `rgba(0, 255, 0, ${(1 - progress) * 0.95})`;
                            ctx.lineWidth = 20 - i * 2;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = 'rgba(0, 255, 0, 0.8)';
                            ctx.beginPath();
                            ctx.moveTo(offset, waveOffset);
                            ctx.lineTo(offset + 500 * progress, waveOffset);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                            
                            // ê²€ê¸° íŒŒí‹°í´ (ë” ë§ì´)
                            for (let j = 0; j < 15; j++) {
                                const particleOffset = offset + (j / 15) * 500 * progress;
                                ctx.fillStyle = `rgba(0, 255, 0, ${(1 - progress) * 0.8})`;
                                ctx.beginPath();
                                ctx.arc(particleOffset, waveOffset + Math.sin(time * 10 + j) * 25, 10, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        ctx.restore();
                        break;
                        
                    case 2: // ì¥ë¹„ - ëŒ€ì§€ ì¶©ê²©íŒŒ (ê±°ëŒ€í•œ ë¹¨ê°„ ì¶©ê²©íŒŒ)
                        const shockwaveRadius = 500 * progress;
                        // ì—¬ëŸ¬ ê²¹ì˜ ì¶©ê²©íŒŒ (ë” ë§ì´)
                        for (let i = 0; i < 8; i++) {
                            const radius = shockwaveRadius - i * 30;
                            const alpha = (1 - progress) * (0.9 - i * 0.1);
                            ctx.strokeStyle = `rgba(255, ${150 - i * 20}, 0, ${alpha})`;
                            ctx.lineWidth = 12 - i;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = 'rgba(255, 100, 0, 0.6)';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                        }
                        // ì¤‘ì•™ í­ë°œ íš¨ê³¼ (ë” í¬ê²Œ)
                        ctx.fillStyle = `rgba(255, 0, 0, ${(1 - progress) * 0.7})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 80 * progress, 0, Math.PI * 2);
                        ctx.fill();
                        // íŒŒí‹°í´ (ë” ë§ì´)
                        for (let i = 0; i < 24; i++) {
                            const angle = (i / 24) * Math.PI * 2;
                            const px = this.x + Math.cos(angle) * shockwaveRadius * 0.9;
                            const py = this.y + Math.sin(angle) * shockwaveRadius * 0.9;
                            ctx.fillStyle = `rgba(255, 150, 0, ${(1 - progress) * 0.9})`;
                            ctx.beginPath();
                            ctx.arc(px, py, 15, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 3: // ì œê°ˆëŸ‰ - ì²œë‘¥ ë²ˆê°œ (í™”ë©´ ì „ì²´ ë²ˆê°œ)
                        // ë²ˆê°œ íš¨ê³¼ (ë” ë§ì´, ë” í¬ê²Œ)
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const dist = 600 * progress;
                            const px = this.x + Math.cos(angle) * dist;
                            const py = this.y + Math.sin(angle) * dist;
                            
                            ctx.strokeStyle = `rgba(255, 255, 0, ${(1 - progress) * 0.95})`;
                            ctx.lineWidth = 8;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y);
                            // ë²ˆê°œ ëª¨ì–‘ (ë” ë³µì¡í•˜ê²Œ)
                            for (let j = 0; j < 8; j++) {
                                const segmentDist = (j + 1) / 8 * dist;
                                const offsetX = Math.sin(time * 8 + j * 2) * 30;
                                const offsetY = Math.cos(time * 8 + j * 2) * 30;
                                ctx.lineTo(
                                    this.x + Math.cos(angle) * segmentDist + offsetX,
                                    this.y + Math.sin(angle) * segmentDist + offsetY
                                );
                            }
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                            
                            // ë²ˆê°œ ëì— í­ë°œ (ë” í¬ê²Œ)
                            ctx.fillStyle = `rgba(255, 255, 0, ${(1 - progress) * 0.9})`;
                            ctx.beginPath();
                            ctx.arc(px, py, 30 * progress, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        // ì¤‘ì•™ ë§ˆë²•ì§„ (ë” í¬ê³  í™”ë ¤í•˜ê²Œ)
                        ctx.fillStyle = `rgba(255, 255, 0, ${(1 - progress) * 0.5})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 600 * progress, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = `rgba(255, 255, 0, ${(1 - progress) * 0.95})`;
                        ctx.lineWidth = 8;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = 'rgba(255, 255, 0, 0.8)';
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, 600 * progress, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        // ë§ˆë²•ì§„ ë‚´ë¶€ ë³„ ëª¨ì–‘
                        for (let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2 + progress * Math.PI;
                            const px = this.x + Math.cos(angle) * 300 * progress;
                            const py = this.y + Math.sin(angle) * 300 * progress;
                            ctx.fillStyle = `rgba(255, 255, 200, ${(1 - progress) * 0.9})`;
                            ctx.beginPath();
                            for (let j = 0; j < 5; j++) {
                                const starAngle = (j * Math.PI * 2 / 5) - Math.PI / 2;
                                const sx = px + Math.cos(starAngle) * 20;
                                const sy = py + Math.sin(starAngle) * 20;
                                if (j === 0) ctx.moveTo(sx, sy);
                                else ctx.lineTo(sx, sy);
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                        break;
                }
            }
            
            drawHeroType(size) {
                // í´ë˜ì‹œë¡œì–„ ìŠ¤íƒ€ì¼: ííŠ¸í•˜ê³  ì‘ì€ ìºë¦­í„°
                const scale = size / 30; // í¬ê¸° ì¡°ì •
                
                switch(this.type) {
                    case 0: // ìœ ë¹„ - ííŠ¸í•œ ì™•ì ìŠ¤íƒ€ì¼
                        // ë¨¸ë¦¬ (í¼ì§í•˜ê²Œ)
                        ctx.fillStyle = '#FFDBAC';
                        ctx.beginPath();
                        ctx.arc(0, -size/3, size/2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ë¨¸ë¦¬ ìœ¤ê³½
                        ctx.strokeStyle = '#D4A574';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // ëˆˆ (ííŠ¸í•˜ê²Œ)
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(-size/8, -size/3, size/20, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(size/8, -size/3, size/20, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ë¯¸ì†Œ
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, -size/4, size/8, 0, Math.PI);
                        ctx.stroke();
                        
                        // ëª¸ì²´ (ì‘ê³  ë‘¥ê¸€ê²Œ)
                        ctx.fillStyle = '#8B4513';
                        ctx.beginPath();
                        ctx.arc(0, size/6, size/2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ê°‘ì˜· ì¥ì‹
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(-size/4, -size/8, size/2, size/4);
                        
                        // ê²€ (ê³µê²© ì• ë‹ˆë©”ì´ì…˜)
                        const swordAngle = -Math.PI/2 + this.attackAnimation * Math.PI/2;
                        ctx.strokeStyle = '#C0C0C0';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(size/3, size/6);
                        ctx.lineTo(
                            size/3 + Math.cos(swordAngle) * size * 1.0,
                            size/6 + Math.sin(swordAngle) * size * 1.0
                        );
                        ctx.stroke();
                        break;
                        
                    case 1: // ê´€ìš° - ííŠ¸í•œ ì¥êµ° ìŠ¤íƒ€ì¼
                        // ë¨¸ë¦¬
                        ctx.fillStyle = '#FFDBAC';
                        ctx.beginPath();
                        ctx.arc(0, -size/3, size/2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#D4A574';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // ëˆˆ
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(-size/8, -size/3, size/20, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(size/8, -size/3, size/20, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ìˆ˜ì—¼ (ì‘ê³  ííŠ¸í•˜ê²Œ)
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-size/6, -size/4, size/3, size/12);
                        
                        // ëª¸ì²´ (ì´ˆë¡ ê°‘ì˜·)
                        ctx.fillStyle = '#228B22';
                        ctx.beginPath();
                        ctx.arc(0, size/6, size/2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ì²­ë£¡ì–¸ì›”ë„ (ê³µê²© ì• ë‹ˆë©”ì´ì…˜)
                        const halberdAngle = -Math.PI/2 + this.attackAnimation * Math.PI/2;
                        ctx.strokeStyle = '#00FF00';
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(size/3, size/6);
                        ctx.lineTo(
                            size/3 + Math.cos(halberdAngle) * size * 1.2,
                            size/6 + Math.sin(halberdAngle) * size * 1.2
                        );
                        ctx.stroke();
                        
                        // ë¬´ê¸° ë ì¥ì‹
                        ctx.fillStyle = '#00FF00';
                        ctx.beginPath();
                        ctx.arc(
                            size/3 + Math.cos(halberdAngle) * size * 1.2,
                            size/6 + Math.sin(halberdAngle) * size * 1.2,
                            size/8, 0, Math.PI * 2
                        );
                        ctx.fill();
                        break;
                        
                    case 2: // ì¥ë¹„ - ííŠ¸í•œ ë¬´ì¥ ìŠ¤íƒ€ì¼
                        // ë¨¸ë¦¬
                        ctx.fillStyle = '#FFDBAC';
                        ctx.beginPath();
                        ctx.arc(0, -size/3, size/2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#D4A574';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // ëˆˆ (í™”ë‚œ í‘œì •)
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-size/8, -size/3, size/10, size/15);
                        ctx.fillRect(size/8 - size/10, -size/3, size/10, size/15);
                        
                        // ìˆ˜ì—¼
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-size/6, -size/4, size/3, size/12);
                        
                        // ëª¸ì²´ (ë¹¨ê°„ ê°‘ì˜·)
                        ctx.fillStyle = '#DC143C';
                        ctx.beginPath();
                        ctx.arc(0, size/6, size/2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ì¥íŒ”ì‚¬ëª¨ (ê³µê²© ì• ë‹ˆë©”ì´ì…˜)
                        const spearAngle = -Math.PI/2 + this.attackAnimation * Math.PI/2;
                        ctx.strokeStyle = '#8B0000';
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(size/3, size/6);
                        ctx.lineTo(
                            size/3 + Math.cos(spearAngle) * size * 1.2,
                            size/6 + Math.sin(spearAngle) * size * 1.2
                        );
                        ctx.stroke();
                        break;
                        
                    case 3: // ì œê°ˆëŸ‰ - ì¹˜ë¹„ ìŠ¤íƒ€ì¼
                        // ë¨¸ë¦¬ (í° ì›í˜•)
                        ctx.fillStyle = '#FFDBAC';
                        ctx.beginPath();
                        ctx.arc(0, -size/3, size/2.2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = '#D4A574';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // ë³¼ í™ì¡°
                        ctx.fillStyle = '#FFB6C1';
                        ctx.beginPath();
                        ctx.arc(-size/5, -size/4, size/12, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(size/5, -size/4, size/12, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ëˆˆ (ì‘ì€ ì )
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(-size/8, -size/3, size/25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(size/8, -size/3, size/25, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ëˆˆì¹ (ë‘êº¼ìš´ ê°ì§„ ëˆˆì¹)
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(-size/6, -size/2.8);
                        ctx.lineTo(-size/10, -size/3.2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(size/6, -size/2.8);
                        ctx.lineTo(size/10, -size/3.2);
                        ctx.stroke();
                        
                        // ë¯¸ì†Œ (ë„“ì€ ë¯¸ì†Œ, í˜€ ë³´ì„)
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(0, -size/5, size/10, 0, Math.PI);
                        ctx.fill();
                        ctx.fillStyle = '#FF69B4';
                        ctx.beginPath();
                        ctx.arc(0, -size/5.5, size/20, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ìˆ˜ì—¼ (ê¸´ ìˆ˜ì—¼)
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.ellipse(0, -size/6, size/6, size/8, 0, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ëª¨ì (ì–´ë‘ìš´ íšŒìƒ‰, ì—¬ëŸ¬ ê°œì˜ ìˆ˜ì§ ë‘¥ê·¼ ì£¼ë¦„)
                        ctx.fillStyle = '#4A4A4A';
                        ctx.beginPath();
                        ctx.arc(0, -size/1.8, size/3.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ëª¨ì ìœ„ìª½ ì£¼ë¦„ë“¤
                        for (let i = -2; i <= 2; i++) {
                            ctx.fillStyle = '#3A3A3A';
                            ctx.beginPath();
                            ctx.arc(i * size/12, -size/1.5, size/20, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // ëª¨ì ë°‘ ê¸ˆìƒ‰ ë°´ë“œ
                        ctx.fillStyle = '#FFD700';
                        ctx.fillRect(-size/3.5, -size/1.6, size*2/3.5, size/15);
                        
                        // ëª¨ì ì•ë©´ ë³´ì„ (ë…¹ìƒ‰/ì²­ë¡ìƒ‰)
                        ctx.fillStyle = '#20B2AA';
                        ctx.beginPath();
                        ctx.ellipse(0, -size/1.65, size/20, size/15, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        
                        // ëª¸ì²´ (ì—°í•œ ë…¹ìƒ‰/ì²­ë¡ìƒ‰ ë¡œë¸Œ)
                        ctx.fillStyle = '#87CEEB';
                        ctx.beginPath();
                        ctx.arc(0, size/6, size/2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ë‚´ë¶€ ì˜ìƒ (ì˜¤ë Œì§€/ì—°í•œ ê°ˆìƒ‰)
                        ctx.fillStyle = '#DEB887';
                        ctx.beginPath();
                        ctx.arc(0, size/5, size/3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // ì™¼ì† ë¶€ì±„ (ê²€ì€ ê¹ƒí„¸ ë¶€ì±„)
                        ctx.save();
                        ctx.translate(-size/3, size/8);
                        ctx.rotate(-Math.PI/6);
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(0, 0, size/4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1;
                        // ë¶€ì±„ ê¹ƒí„¸ íš¨ê³¼
                        for (let i = 0; i < 5; i++) {
                            const angle = (i - 2) * Math.PI / 8;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.cos(angle) * size/4, Math.sin(angle) * size/4);
                            ctx.stroke();
                        }
                        ctx.restore();
                        
                        // ë¶€ì±„ì—ì„œ ë‚˜ì˜¤ëŠ” ì—°ê¸° íš¨ê³¼
                        if (this.attackAnimation > 0) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${this.attackAnimation * 0.7})`;
                            for (let i = 0; i < 3; i++) {
                                const offsetX = -size/3 + Math.sin(this.attackAnimation * 2 + i) * size/8;
                                const offsetY = size/8 - this.attackAnimation * size/2 - i * size/10;
                                ctx.beginPath();
                                ctx.arc(offsetX, offsetY, size/15 * (1 - this.attackAnimation), 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        
                        // ì˜¤ë¥¸ì† ë©”ê°€í° (ê³µê²© ì‹œ)
                        if (this.attackAnimation > 0.3) {
                            ctx.save();
                            ctx.translate(size/3, size/8);
                            ctx.rotate(Math.PI/6);
                            // ë©”ê°€í° ë³¸ì²´ (ì—°í•œ íŒŒë€ìƒ‰)
                            ctx.fillStyle = '#87CEFA';
                            ctx.beginPath();
                            ctx.arc(0, 0, size/5, 0, Math.PI * 2);
                            ctx.fill();
                            // ë©”ê°€í° ë‚´ë¶€ (ë¹¨ê°„ìƒ‰)
                            ctx.fillStyle = '#FF6347';
                            ctx.beginPath();
                            ctx.arc(0, 0, size/8, 0, Math.PI * 2);
                            ctx.fill();
                            // ë©”ê°€í° ì†ì¡ì´
                            ctx.fillStyle = '#87CEFA';
                            ctx.fillRect(-size/20, size/6, size/10, size/4);
                            ctx.restore();
                        }
                        
                        // ë§ˆë²• ê³µê²© ì´í™íŠ¸ (ë³„ ëª¨ì–‘)
                        if (this.attackAnimation > 0.5) {
                            ctx.fillStyle = `rgba(255, 255, 0, ${this.attackAnimation * 0.6})`;
                            ctx.beginPath();
                            for (let i = 0; i < 5; i++) {
                                const angle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                                const x = Math.cos(angle) * size * (0.5 + this.attackAnimation);
                                const y = Math.sin(angle) * size * (0.5 + this.attackAnimation);
                                if (i === 0) ctx.moveTo(x, y);
                                else ctx.lineTo(x, y);
                            }
                            ctx.closePath();
                            ctx.fill();
                        }
                        break;
                }
            }
        }
        
        // ì  í´ë˜ìŠ¤
        class Enemy {
            constructor() {
                this.path = this.generatePath();
                this.pathIndex = 0;
                this.x = this.path[0].x;
                this.y = this.path[0].y;
                // ë¼ìš´ë“œë³„ ë‚œì´ë„ ì¦ê°€
                const healthMultiplier = 1 + (round - 1) * 0.3; // ë¼ìš´ë“œë§ˆë‹¤ 30% ì¦ê°€
                const speedMultiplier = 1 + (round - 1) * 0.15; // ë¼ìš´ë“œë§ˆë‹¤ 15% ì¦ê°€
                this.health = Math.floor(150 * healthMultiplier); // ê¸°ë³¸ ì²´ë ¥ 150ìœ¼ë¡œ ì¦ê°€
                this.maxHealth = this.health;
                this.speed = Math.floor(30 * speedMultiplier);
                this.alive = true;
                this.walkAnimation = 0;
            }
            
            generatePath() {
                // generatePath í•¨ìˆ˜ ì‚¬ìš©í•˜ì—¬ ë™ì¼í•œ ê²½ë¡œ ìƒì„±
                return generatePath();
            }
            
            update(dt) {
                if (this.pathIndex >= this.path.length - 1) {
                    this.alive = false;
                    lives--;
                    updateUI();
                    return;
                }
                
                this.walkAnimation += dt * 10;
                
                const target = this.path[this.pathIndex + 1];
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 5) {
                    this.pathIndex++;
                } else {
                    this.x += (dx / dist) * this.speed * dt;
                    this.y += (dy / dist) * this.speed * dt;
                }
            }
            
            takeDamage(damage) {
                this.health -= damage;
                
                // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸ ìƒì„±
                damageTexts.push(new DamageText(this.x, this.y - 30, damage));
                
                if (this.health <= 0) {
                    this.alive = false;
                    // ë¼ìš´ë“œë³„ ë³´ìƒ ì¦ê°€
                    const goldReward = Math.floor(10 + round * 2);
                    gold += goldReward;
                    updateUI();
                }
            }
            
            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜
                const walkOffset = Math.sin(this.walkAnimation) * 3;
                ctx.translate(0, walkOffset);
                
                const size = 20;
                
                // ê·¸ë¦¼ì
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(0, size + 3, size * 0.8, size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // ëª¸ì²´
                ctx.fillStyle = '#8B0000';
                ctx.fillRect(-size/3, -size/2, size*2/3, size);
                
                // ë¨¸ë¦¬
                ctx.fillStyle = '#FF6B6B';
                ctx.beginPath();
                ctx.arc(0, -size/2, size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // ëˆˆ
                ctx.fillStyle = '#000';
                ctx.fillRect(-size/6, -size/2, size/12, size/12);
                ctx.fillRect(size/12, -size/2, size/12, size/12);
                
                ctx.restore();
                
                // ì²´ë ¥ë°”
                const barWidth = size * 2;
                const barHeight = 3;
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - barWidth / 2, this.y - size - 10, barWidth, barHeight);
                ctx.fillStyle = '#f00';
                ctx.fillRect(this.x - barWidth / 2, this.y - size - 10, barWidth * (this.health / this.maxHealth), barHeight);
            }
        }
        
        // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸ í´ë˜ìŠ¤
        class DamageText {
            constructor(x, y, damage) {
                this.x = x;
                this.y = y;
                this.damage = damage;
                this.lifetime = 1.0; // 1ì´ˆê°„ í‘œì‹œ
                this.offsetY = 0; // ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ì˜¤í”„ì…‹
                this.alpha = 1.0; // íˆ¬ëª…ë„
            }
            
            update(dt) {
                this.lifetime -= dt;
                this.offsetY -= 30 * dt; // ìœ„ë¡œ ì´ë™
                this.alpha = Math.max(0, this.lifetime); // í˜ì´ë“œì•„ì›ƒ
            }
            
            draw() {
                if (this.lifetime <= 0) return;
                
                ctx.save();
                ctx.globalAlpha = this.alpha;
                
                // í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼
                ctx.font = 'bold 20px Arial';
                ctx.fillStyle = '#FF0000';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸° (ì™¸ê³½ì„  + ì±„ìš°ê¸°)
                const text = `-${Math.ceil(this.damage)}`;
                ctx.strokeText(text, this.x, this.y + this.offsetY);
                ctx.fillText(text, this.x, this.y + this.offsetY);
                
                ctx.restore();
            }
            
            isAlive() {
                return this.lifetime > 0;
            }
        }
        
        // ê²Œì„ ê°ì²´
        const heroes = [];
        const enemies = [];
        const damageTexts = []; // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸ ë°°ì—´
        let waveTimer = 0;
        const waveInterval = 3;
        
        // UI ì—…ë°ì´íŠ¸
        function updateUI() {
            document.getElementById('gold').textContent = gold;
            document.getElementById('round').textContent = round;
            document.getElementById('lives').textContent = lives;
        }
        
        // ì˜ì›… ì„ íƒ ë²„íŠ¼ ì´ë²¤íŠ¸
        document.querySelectorAll('.hero-btn').forEach((btn, index) => {
            btn.addEventListener('click', () => {
                if (gold >= heroCosts[index]) {
                    placingHeroType = index;
                    selectedHero = null;
                    document.querySelectorAll('.hero-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                } else {
                    alert('ê¸ˆí™”ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!');
                }
            });
        });
        
        // ìº”ë²„ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (placingHeroType !== null) {
                // íƒ€ì›Œ ìŠ¬ë¡¯ ì°¾ê¸°
                let clickedSlot = null;
                for (let i = 0; i < towerSlots.length; i++) {
                    const slot = towerSlots[i];
                    const dist = Math.sqrt((x - slot.x) ** 2 + (y - slot.y) ** 2);
                    if (dist < 30) {
                        clickedSlot = i;
                        break;
                    }
                }
                
                if (clickedSlot !== null) {
                    // ìŠ¬ë¡¯ì´ ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ì§€ í™•ì¸
                    const slotOccupied = heroes.some(h => h.slotIndex === clickedSlot);
                    
                    if (!slotOccupied) {
                        if (gold >= heroCosts[placingHeroType]) {
                            const slot = towerSlots[clickedSlot];
                            heroes.push(new Hero(slot.x, slot.y, placingHeroType, clickedSlot));
                            gold -= heroCosts[placingHeroType];
                            placingHeroType = null;
                            document.querySelectorAll('.hero-btn').forEach(b => b.classList.remove('selected'));
                            updateUI();
                        } else {
                            alert('ê¸ˆí™”ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!');
                        }
                    } else {
                        alert('ì´ë¯¸ íƒ€ì›Œê°€ ì„¤ì¹˜ëœ ìœ„ì¹˜ì…ë‹ˆë‹¤!');
                    }
                }
            } else {
                // ì˜ì›… ì„ íƒ ë˜ëŠ” ìŠ¤í‚¬ ì‚¬ìš©
                let clickedHero = null;
                for (const hero of heroes) {
                    const dist = Math.sqrt((x - hero.x) ** 2 + (y - hero.y) ** 2);
                    if (dist < 30) {
                        clickedHero = hero;
                        break;
                    }
                }
                
                if (clickedHero) {
                    if (selectedHero === clickedHero && clickedHero.canUseSkill()) {
                        // ê°™ì€ ì˜ì›…ì„ ë‹¤ì‹œ í´ë¦­í•˜ê³  ìŠ¤í‚¬ì´ ì¤€ë¹„ë˜ì–´ ìˆìœ¼ë©´ ìŠ¤í‚¬ ì‚¬ìš©
                        clickedHero.useSkill(enemies);
                        updateSkillInfo();
                    } else {
                        // ì˜ì›… ì„ íƒ
                        selectedHero = clickedHero;
                        updateSkillInfo();
                    }
                } else {
                    selectedHero = null;
                    updateSkillInfo();
                }
            }
        });
        
        // ì  ìƒì„±
        function spawnEnemy() {
            enemies.push(new Enemy());
        }
        
        // ë¼ìš´ë“œ ì‹œì‘
        function startRound() {
            // 3ë¼ìš´ë“œë§ˆë‹¤ ë³´ìŠ¤ ì¶œí˜„
            const isBossRound = round % 3 === 0;
            
            if (isBossRound) {
                // ë³´ìŠ¤ ë¼ìš´ë“œ: ë³´ìŠ¤ 1ë§ˆë¦¬ + ì¼ë°˜ ëª¬ìŠ¤í„° ì ê²Œ
                setTimeout(() => {
                    spawnBoss();
                }, 1000);
                
                // ë³´ìŠ¤ ë¼ìš´ë“œì—ëŠ” ì¼ë°˜ ëª¬ìŠ¤í„°ë„ ì¼ë¶€ ìŠ¤í°
                const enemyCount = Math.floor(5 + round * 2);
                const spawnInterval = Math.max(300, 1000 - (round - 1) * 60);
                
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => spawnEnemy(), 2000 + i * spawnInterval);
                }
            } else {
                // ì¼ë°˜ ë¼ìš´ë“œ: ë¼ìš´ë“œë³„ ì  ìˆ˜ ì¦ê°€ (ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ì¦ê°€)
                const enemyCount = Math.floor(10 + round * 5 + (round - 1) * (round - 1) * 2.5);
                const spawnInterval = Math.max(300, 1000 - (round - 1) * 60);
                
                for (let i = 0; i < enemyCount; i++) {
                    setTimeout(() => spawnEnemy(), i * spawnInterval);
                }
            }
        }
        
        // ê²½ë¡œ ê·¸ë¦¬ê¸°
        function drawPath() {
            const path = generatePath();
            ctx.strokeStyle = '#646464';
            ctx.lineWidth = 40;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
            
            // ì‹œì‘ì  í‘œì‹œ (ì„±/ìš”ìƒˆ)
            const startPoint = path[0];
            ctx.save();
            ctx.translate(startPoint.x, startPoint.y);
            
            // ì„±ë²½
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-30, -40, 60, 50);
            
            // ì„±ë²½ ìœ—ë¶€ë¶„ (í†±ë‹ˆ ëª¨ì–‘)
            ctx.fillStyle = '#654321';
            for (let i = 0; i < 5; i++) {
                ctx.fillRect(-30 + i * 12, -40, 8, 10);
            }
            
            // ê¹ƒë°œ
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(25, -45, 8, 20);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(29, -35, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // ë¬¸
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(-15, -20, 30, 25);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(-12, -17, 6, 6);
            ctx.fillRect(6, -17, 6, 6);
            
            ctx.restore();
            
            // ì‹œì‘ì  í…ìŠ¤íŠ¸
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText('ì‹œì‘', startPoint.x, startPoint.y - 60);
            ctx.fillText('ì‹œì‘', startPoint.x, startPoint.y - 60);
            
            // ëì  í‘œì‹œ (ëª©í‘œ ì§€ì /ì„±)
            const endPoint = path[path.length - 1];
            ctx.save();
            ctx.translate(endPoint.x, endPoint.y);
            
            // ì„±ë²½
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(-30, -40, 60, 50);
            
            // ì„±ë²½ ìœ—ë¶€ë¶„
            ctx.fillStyle = '#654321';
            for (let i = 0; i < 5; i++) {
                ctx.fillRect(-30 + i * 12, -40, 8, 10);
            }
            
            // ê¹ƒë°œ (ë‹¤ë¥¸ ìƒ‰)
            ctx.fillStyle = '#0000FF';
            ctx.fillRect(25, -45, 8, 20);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(29, -35, 5, 0, Math.PI * 2);
            ctx.fill();
            
            // ë¬¸
            ctx.fillStyle = '#4A4A4A';
            ctx.fillRect(-15, -20, 30, 25);
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(-12, -17, 6, 6);
            ctx.fillRect(6, -17, 6, 6);
            
            // ëª©í‘œ ì§€ì  í‘œì‹œ (ë¹¨ê°„ ì›)
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(0, 0, 25, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.restore();
            
            // ëì  í…ìŠ¤íŠ¸
            ctx.fillStyle = '#FFF';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 3;
            ctx.strokeText('ëª©í‘œ', endPoint.x, endPoint.y - 60);
            ctx.fillText('ëª©í‘œ', endPoint.x, endPoint.y - 60);
        }
        
        // íƒ€ì›Œ ìŠ¬ë¡¯ ê·¸ë¦¬ê¸°
        function drawTowerSlots() {
            for (let i = 0; i < towerSlots.length; i++) {
                const slot = towerSlots[i];
                const occupied = heroes.some(h => h.slotIndex === i);
                
                ctx.strokeStyle = occupied ? 'rgba(255, 0, 0, 0.3)' : 'rgba(0, 255, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(slot.x - 30, slot.y - 30, 60, 60);
                ctx.setLineDash([]);
                
                // ì‚¬ìš© ê°€ëŠ¥í•œ ìŠ¬ë¡¯ì—ë§Œ ë°°ì¹˜ ê°€ëŠ¥ í‘œì‹œ
                if (!occupied && placingHeroType !== null) {
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                    ctx.fillRect(slot.x - 30, slot.y - 30, 60, 60);
                }
            }
        }
        
        // ê²Œì„ ì—…ë°ì´íŠ¸
        function update(dt) {
            // ì  ì—…ë°ì´íŠ¸
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].update(dt);
                if (!enemies[i].alive) {
                    enemies.splice(i, 1);
                }
            }
            
            // ì˜ì›… ì—…ë°ì´íŠ¸
            for (const hero of heroes) {
                hero.update(dt, enemies);
            }
            
            // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            for (let i = damageTexts.length - 1; i >= 0; i--) {
                damageTexts[i].update(dt);
                if (!damageTexts[i].isAlive()) {
                    damageTexts.splice(i, 1);
                }
            }
            
            // ìŠ¤í‚¬ ì •ë³´ ì—…ë°ì´íŠ¸
            updateSkillInfo();
            
            // ì›¨ì´ë¸Œ ìƒì„±
            waveTimer += dt;
            if (waveTimer >= waveInterval && enemies.length === 0) {
                round++;
                waveTimer = 0;
                // ë¼ìš´ë“œ ì‹œì‘ ì „ ì•Œë¦¼
                setTimeout(() => {
                    alert(`ë¼ìš´ë“œ ${round} ì‹œì‘!\në‚œì´ë„ê°€ ì¦ê°€í•©ë‹ˆë‹¤.`);
                    startRound();
                }, 500);
                updateUI();
            }
            
            // ê²Œì„ ì˜¤ë²„ ì²´í¬
            if (lives <= 0) {
                alert(`ê²Œì„ ì˜¤ë²„! ${round - 1}ë¼ìš´ë“œê¹Œì§€ ìƒì¡´í–ˆìŠµë‹ˆë‹¤.`);
                location.reload();
            }
        }
        
        // ê²Œì„ ê·¸ë¦¬ê¸°
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawPath();
            drawTowerSlots();
            
            // ì  ê·¸ë¦¬ê¸°
            for (const enemy of enemies) {
                enemy.draw();
            }
            
            // ì˜ì›… ê·¸ë¦¬ê¸°
            for (const hero of heroes) {
                hero.draw();
            }
            
            // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸ ê·¸ë¦¬ê¸°
            for (const damageText of damageTexts) {
                damageText.draw();
            }
            
            // ë³´ìŠ¤ ì¶œí˜„ ì•Œë¦¼ ê·¸ë¦¬ê¸°
            drawBossAlert();
        }
        
        // ë³´ìŠ¤ ì¶œí˜„ ì•Œë¦¼ ê·¸ë¦¬ê¸°
        function drawBossAlert() {
            if (showBossAlert) {
                const bossAlert = document.getElementById('bossAlert');
                const bossRoundNumber = document.getElementById('bossRoundNumber');
                bossRoundNumber.textContent = round;
                bossAlert.classList.add('show');
            }
        }
        
        // ë°°ì† ì¡°ì ˆ ë²„íŠ¼ ì´ë²¤íŠ¸
        document.querySelectorAll('.speed-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                gameSpeed = parseFloat(btn.dataset.speed);
                document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById('speedDisplay').textContent = gameSpeed.toFixed(1) + 'x';
            });
        });
        
        // ê²Œì„ ë£¨í”„
        let lastTime = 0;
        function gameLoop(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.1) * gameSpeed;
            lastTime = currentTime;
            
            update(dt);
            draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        // ê²Œì„ ì‹œì‘
        startRound();
        updateUI();
        gameLoop(0);
    </script>
</body>
</html>

