<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>삼국지 러쉬 오리진</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Malgun Gothic', sans-serif;
            background: #1a1a2e;
            color: white;
            overflow: hidden;
            margin: 0;
            padding: 0;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            background: #0f3460;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #topUI {
            position: absolute;
            top: clamp(10px, 1.5vh, 15px);
            left: clamp(10px, 1.5vw, 15px);
            display: flex;
            flex-direction: column;
            gap: clamp(5px, 1vh, 10px);
            font-size: clamp(14px, 2vw, 24px);
            font-weight: bold;
            z-index: 100;
            pointer-events: none;
        }
        
        #topUI > div {
            pointer-events: none;
        }
        
        #gold {
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        #treasure {
            color: #9370db;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        #round {
            color: #87ceeb;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        #topButtons {
            position: absolute;
            top: clamp(10px, 1.5vh, 15px);
            right: clamp(10px, 1.5vw, 15px);
            display: flex;
            flex-direction: column;
            gap: clamp(5px, 1vh, 8px);
            z-index: 100;
            pointer-events: none;
        }
        
        #shopButton, #heroManageButton {
            padding: clamp(8px, 1.5vw, 12px) clamp(15px, 2vw, 20px);
            background: #4169e1;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: clamp(12px, 1.8vw, 18px);
            pointer-events: auto;
            white-space: nowrap;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
        }
        
        #heroManageButton {
            background: #32cd32;
        }
        
        #shopButton:hover, #heroManageButton:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }
        
        #heroSelection {
            position: absolute;
            bottom: clamp(10px, 1.5vh, 15px);
            left: clamp(10px, 1.5vw, 15px);
            display: flex;
            gap: clamp(5px, 1vw, 10px);
            pointer-events: auto;
            flex-wrap: wrap;
            max-width: calc(100% - 40px);
            z-index: 100;
        }
        
        .hero-btn {
            padding: clamp(6px, 1vw, 10px) clamp(10px, 1.5vw, 15px);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid #fff;
            border-radius: 5px;
            cursor: pointer;
            font-size: clamp(10px, 1.5vw, 14px);
            white-space: nowrap;
        }
        
        .hero-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .hero-btn.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.3);
        }
        
        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(900px, 95vw);
            max-height: 90vh;
            background: rgba(30, 30, 50, 0.98);
            border: 3px solid white;
            border-radius: 10px;
            padding: clamp(15px, 3vw, 30px);
            display: none;
            overflow-y: auto;
            pointer-events: auto;
            z-index: 1000;
        }
        
        .modal.show {
            display: block;
        }
        
        .modal-title {
            font-size: clamp(20px, 4vw, 32px);
            margin-bottom: clamp(10px, 2vw, 20px);
            text-align: center;
        }
        
        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            background: #dc143c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .close-btn:hover {
            background: #ff1744;
        }
        
        .shop-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .tab-btn {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 2px solid white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .tab-btn.active {
            background: #4169e1;
            border-color: #4169e1;
        }
        
        .shop-item {
            padding: clamp(10px, 1.5vw, 15px);
            margin: clamp(5px, 1vw, 10px) 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .shop-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .shop-item:active {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .item-name {
            font-size: clamp(14px, 2.5vw, 20px);
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .item-cost {
            color: #ffd700;
        }
        
        .item-cost.treasure {
            color: #9370db;
        }
        
        .gacha-section {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .gacha-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .gacha-btn {
            padding: clamp(10px, 2vw, 15px) clamp(20px, 3vw, 30px);
            font-size: clamp(14px, 2.5vw, 20px);
            border: none;
            border-radius: 10px;
            cursor: pointer;
            color: white;
            font-weight: bold;
        }
        
        .gacha-btn.single {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        
        .gacha-btn.multi {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }
        
        .gacha-btn:hover {
            transform: scale(1.05);
            transition: transform 0.2s;
        }
        
        .gacha-result {
            margin-top: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            display: none;
        }
        
        .gacha-result.show {
            display: block;
        }
        
        .hero-card {
            display: inline-block;
            width: 120px;
            height: 160px;
            margin: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            text-align: center;
            position: relative;
            border: 3px solid;
            transition: transform 0.2s;
        }
        
        .hero-card:hover {
            transform: scale(1.1);
        }
        
        .hero-card.N { border-color: #808080; }
        .hero-card.R { border-color: #4169e1; }
        .hero-card.SR { border-color: #9370db; }
        .hero-card.SSR { border-color: #ffd700; }
        
        .hero-card-name {
            font-size: 14px;
            font-weight: bold;
            margin-top: 5px;
        }
        
        .hero-card-grade {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 12px;
            font-weight: bold;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        .hero-card.N .hero-card-grade { background: #808080; }
        .hero-card.R .hero-card-grade { background: #4169e1; }
        .hero-card.SR .hero-card-grade { background: #9370db; }
        .hero-card.SSR .hero-card-grade { background: #ffd700; color: #000; }
        
        .star-rating {
            margin-top: 5px;
            font-size: 16px;
            color: #ffd700;
        }
        
        .hero-collection {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(min(150px, 30vw), 1fr));
            gap: clamp(10px, 2vw, 15px);
            margin-top: clamp(10px, 2vw, 20px);
        }
        
        .collection-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: clamp(10px, 1.5vw, 15px);
            border: 3px solid;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .collection-card:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-5px);
        }
        
        .collection-card.N { border-color: #808080; }
        .collection-card.R { border-color: #4169e1; }
        .collection-card.SR { border-color: #9370db; }
        .collection-card.SSR { border-color: #ffd700; }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .card-name {
            font-size: clamp(14px, 2.2vw, 18px);
            font-weight: bold;
        }
        
        .card-count {
            background: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        .enhance-btn {
            width: 100%;
            padding: clamp(6px, 1vw, 10px);
            margin-top: clamp(5px, 1vw, 10px);
            background: #32cd32;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: clamp(11px, 1.5vw, 14px);
        }
        
        .enhance-btn:hover {
            background: #228b22;
        }
        
        .enhance-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: clamp(8px, 1.5vw, 15px);
            border-radius: 5px;
            font-size: clamp(10px, 1.5vw, 14px);
            pointer-events: auto;
            max-width: calc(100% - 20px);
        }
        
        .desktop-only {
            display: inline;
        }
        
        .mobile-only {
            display: none;
        }
        
        /* 반응형 미디어 쿼리 */
        @media (max-width: 768px) {
            #topUI {
                gap: 8px;
                font-size: clamp(14px, 3vw, 18px);
            }
            
            #shopButton, #heroManageButton {
                padding: clamp(12px, 2vh, 16px) clamp(16px, 3vw, 24px);
                font-size: clamp(14px, 2.5vw, 18px);
                min-height: 44px; /* 최소 터치 영역 */
                min-width: 120px;
            }
            
            #heroManageButton {
                right: auto;
            }
            
            #topButtons {
                flex-direction: row;
                gap: 10px;
                flex-wrap: wrap;
            }
            
            .hero-btn {
                padding: clamp(10px, 2vh, 14px) clamp(12px, 2.5vw, 18px);
                font-size: clamp(12px, 2vw, 16px);
                min-height: 44px; /* 최소 터치 영역 */
                min-width: 80px;
            }
            
            .modal {
                width: 98vw;
                max-height: 95vh;
                padding: 15px;
            }
            
            .hero-detail-top {
                height: 50%;
            }
            
            .hero-detail-bottom {
                height: 50%;
                flex-direction: column;
                overflow-y: auto;
            }
            
            .hero-preview-section {
                width: 100%;
            }
            
            .hero-info-section {
                width: 100%;
            }
            
            .hero-stats-grid {
                grid-template-columns: 1fr;
            }
            
            .equipment-slots-side {
                gap: 8px;
            }
            
            .equipment-slot-side {
                width: 60px;
                height: 60px;
            }
            
            .equipment-slot-icon {
                font-size: 24px;
            }
            
            .hero-illustration-large {
                width: min(250px, 50vw);
            }
            
            .intro-title {
                font-size: clamp(32px, 8vw, 72px);
            }
            
            .intro-subtitle {
                font-size: clamp(16px, 3vw, 24px);
            }
            
            .intro-btn {
                padding: 12px 30px;
                font-size: clamp(16px, 3vw, 24px);
                min-width: 200px;
            }
            
            .gacha-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .gacha-btn {
                width: 90%;
                max-width: 300px;
            }
        }
        
        @media (max-width: 480px) {
            #topUI {
                flex-direction: column;
                gap: 6px;
                font-size: clamp(12px, 3vw, 16px);
            }
            
            #topButtons {
                position: absolute;
                top: clamp(10px, 2vh, 15px);
                right: clamp(5px, 1vw, 10px);
                flex-direction: column;
                gap: 8px;
            }
            
            #shopButton, #heroManageButton {
                padding: clamp(14px, 2.5vh, 18px) clamp(18px, 4vw, 24px);
                font-size: clamp(13px, 3vw, 16px);
                min-height: 48px; /* 더 큰 터치 영역 */
                min-width: 140px;
            }
            
            .hero-btn {
                padding: clamp(12px, 2vh, 16px) clamp(14px, 3vw, 20px);
                font-size: clamp(11px, 2.5vw, 14px);
                min-height: 44px; /* 최소 터치 영역 */
                min-width: 70px;
            }
            
            #heroSelection {
                bottom: clamp(5px, 1vh, 10px);
                left: clamp(5px, 1vw, 10px);
                gap: 8px;
                max-width: calc(100% - 20px);
            }
            
            #instructions {
                display: none;
            }
            
            .modal {
                width: 100vw;
                height: 100vh;
                max-height: 100vh;
                border-radius: 0;
                padding: clamp(10px, 2vw, 20px);
                top: 0;
                left: 0;
                transform: none;
            }
            
            .close-btn {
                padding: clamp(12px, 2vh, 16px) clamp(20px, 4vw, 28px);
                font-size: clamp(14px, 3vw, 18px);
                min-height: 44px;
                top: clamp(5px, 1vh, 10px);
                right: clamp(5px, 1vw, 10px);
            }
            
            .hero-detail-top {
                height: 45%;
            }
            
            .hero-detail-bottom {
                height: 55%;
            }
            
            .equipment-slots-side {
                gap: 5px;
            }
            
            .equipment-slot-side {
                width: min(50px, 10vw);
                height: min(50px, 10vw);
            }
            
            .batch-btn {
                padding: 6px 10px;
                font-size: 11px;
            }
            
            .hero-stats-grid {
                grid-template-columns: 1fr;
            }
            
            .hero-skills-section {
                justify-content: center;
            }
            
            .hero-actions {
                flex-direction: column;
            }
            
            .action-btn {
                width: 100%;
            }
        }
        
        @media (orientation: landscape) and (max-height: 600px) {
            .hero-detail-top {
                height: 60%;
            }
            
            .hero-detail-bottom {
                height: 40%;
                flex-direction: row;
            }
            
            .hero-illustration-large {
                width: min(200px, 30vw);
            }
            
            .hero-preview-section {
                width: min(200px, 25vw);
            }
        }
        
        /* 터치 디바이스 최적화 */
        @media (hover: none) and (pointer: coarse) {
            .desktop-only {
                display: none !important;
            }
            
            .mobile-only {
                display: inline !important;
            }
            
            .hero-btn:hover,
            .shop-item:hover,
            .inventory-item:hover,
            .equipment-slot:hover,
            .equipment-slot-side:hover,
            .skill-icon:hover {
                transform: none;
            }
            
            .hero-btn:active,
            .shop-item:active,
            .inventory-item:active {
                transform: scale(0.95);
            }
            
            /* 모바일에서 모든 버튼 크기 확대 */
            button, .hero-btn, .tab-btn, .gacha-btn, .close-btn {
                min-height: 44px;
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(255, 255, 255, 0.3);
            }
            
            /* 모바일에서 스크롤 개선 */
            .modal {
                -webkit-overflow-scrolling: touch;
            }
        }
        
        /* 모바일 전용 스타일 */
        @media (max-width: 768px) {
            .desktop-only {
                display: none !important;
            }
            
            .mobile-only {
                display: inline !important;
            }
            
            /* 터치 영역 확대 */
            .tab-btn {
                padding: clamp(12px, 2vh, 16px) clamp(16px, 3vw, 24px);
                font-size: clamp(14px, 2.5vw, 18px);
                min-height: 44px;
            }
            
            .gacha-btn {
                padding: clamp(14px, 2.5vh, 18px) clamp(20px, 4vw, 30px);
                font-size: clamp(16px, 3vw, 20px);
                min-height: 48px;
            }
            
            .shop-item, .inventory-item {
                padding: clamp(12px, 2vh, 16px);
                min-height: 60px;
            }
            
            .equipment-slot, .equipment-slot-side {
                min-width: 60px;
                min-height: 60px;
            }
        }
        
        /* 인트로 화면 스타일 */
        #introScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #4a90e2 0%, #87ceeb 50%, #ffb6c1 100%);
            z-index: 5000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        #introScreen.hidden {
            display: none;
        }
        
        .sky-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        .cloud {
            position: absolute;
            border-radius: 50px;
            opacity: 0.7;
            animation: float 20s infinite ease-in-out;
        }
        
        .cloud1 {
            width: 300px;
            height: 100px;
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            top: 20%;
            left: -100px;
            animation-delay: 0s;
        }
        
        .cloud2 {
            width: 250px;
            height: 80px;
            background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
            top: 40%;
            right: -100px;
            animation-delay: 5s;
        }
        
        .cloud3 {
            width: 350px;
            height: 120px;
            background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
            bottom: 30%;
            left: 10%;
            animation-delay: 10s;
        }
        
        @keyframes float {
            0%, 100% { transform: translateX(0) translateY(0); }
            25% { transform: translateX(50px) translateY(-20px); }
            50% { transform: translateX(100px) translateY(10px); }
            75% { transform: translateX(50px) translateY(-10px); }
        }
        
        .intro-title {
            font-size: 72px;
            font-weight: bold;
            color: #fff;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
            z-index: 10;
            animation: titleGlow 2s infinite alternate;
        }
        
        @keyframes titleGlow {
            from { text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.5); }
            to { text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.5), 0 0 30px rgba(255, 215, 0, 0.8); }
        }
        
        .intro-subtitle {
            font-size: 24px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 50px;
            z-index: 10;
        }
        
        .intro-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 10;
            align-items: center;
        }
        
        .intro-btn {
            padding: 18px 50px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            border: 3px solid #ffd700;
            border-radius: 10px;
            cursor: pointer;
            background: linear-gradient(135deg, #ff6b6b 0%, #ffa500 100%);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s;
            min-width: 250px;
        }
        
        .intro-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #ff5252 0%, #ff8c00 100%);
        }
        
        .intro-btn:active {
            transform: scale(0.98);
        }
        
        .intro-top-buttons {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }
        
        .intro-top-btn {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .intro-top-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .intro-version {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.8);
            z-index: 10;
        }
        
        .chibi-character {
            position: absolute;
            z-index: 5;
            animation: characterFloat 3s infinite ease-in-out;
        }
        
        .chibi-character img {
            width: 150px;
            height: auto;
        }
        
        @keyframes characterFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        
        .chibi-1 {
            bottom: 15%;
            left: 10%;
            animation-delay: 0s;
        }
        
        .chibi-2 {
            bottom: 15%;
            right: 10%;
            animation-delay: 1s;
        }
        
        .chibi-3 {
            bottom: 25%;
            left: 25%;
            animation-delay: 0.5s;
        }
        
        .chibi-4 {
            bottom: 25%;
            right: 25%;
            animation-delay: 1.5s;
        }
        
        .chibi-5 {
            bottom: 35%;
            left: 50%;
            transform: translateX(-50%);
            animation-delay: 1s;
        }
        
        /* 캐릭터 SVG 스타일 */
        .chibi-svg {
            width: min(120px, 15vw);
            height: min(150px, 20vh);
            filter: drop-shadow(0 5px 15px rgba(0, 0, 0, 0.5));
        }
        
        /* 영웅 상세 화면 - 새로운 스타일 */
        .hero-detail-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            min-height: 600px;
        }
        
        .hero-detail-top {
            position: relative;
            width: 100%;
            height: 55%;
            min-height: 300px;
            background: linear-gradient(to bottom, #4a148c 0%, #7b1fa2 50%, #9c27b0 100%);
            overflow: hidden;
        }
        
        .hero-illustration-large {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: min(400px, 40vw);
            height: 100%;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            z-index: 2;
        }
        
        .hero-illustration-large svg {
            width: 100%;
            height: auto;
            filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.5));
        }
        
        .hero-top-info {
            position: absolute;
            top: clamp(10px, 2vw, 20px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: clamp(8px, 1.5vw, 15px);
            z-index: 10;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .hero-badge {
            background: linear-gradient(135deg, #c0c0c0 0%, #e8e8e8 100%);
            padding: clamp(5px, 1vw, 8px) clamp(10px, 1.5vw, 15px);
            border-radius: 8px;
            font-weight: bold;
            color: #333;
            display: flex;
            align-items: center;
            gap: clamp(3px, 0.5vw, 5px);
            font-size: clamp(12px, 1.8vw, 16px);
        }
        
        .hero-badge-stars {
            color: #dc143c;
        }
        
        .hero-name-top {
            font-size: clamp(20px, 4vw, 32px);
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .hero-star-slots {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        
        .star-slot {
            width: clamp(12px, 2vw, 20px);
            height: clamp(12px, 2vw, 20px);
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .star-slot.filled {
            background: #dc143c;
            border-color: #ff1744;
        }
        
        .equipment-slots-side {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
            z-index: 5;
        }
        
        .equipment-slots-left {
            left: clamp(15px, 3vw, 30px);
        }
        
        .equipment-slots-right {
            right: clamp(15px, 3vw, 30px);
        }
        
        .equipment-slot-side {
            width: min(100px, 12vw);
            height: min(100px, 12vw);
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .equipment-slot-side:hover {
            border-color: #ffd700;
            transform: scale(1.1);
        }
        
        .equipment-slot-side.equipped {
            border-color: #32cd32;
            background: rgba(50, 205, 50, 0.3);
        }
        
        .equipment-slot-icon {
            font-size: clamp(24px, 4vw, 36px);
            margin-bottom: 5px;
        }
        
        .equipment-slot-stars {
            position: absolute;
            top: clamp(3px, 0.5vw, 5px);
            right: clamp(3px, 0.5vw, 5px);
            font-size: clamp(8px, 1.2vw, 12px);
            color: #ffd700;
        }
        
        .equipment-batch-buttons {
            position: absolute;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }
        
        .equipment-batch-buttons.left {
            left: clamp(15px, 3vw, 30px);
        }
        
        .equipment-batch-buttons.right {
            right: clamp(15px, 3vw, 30px);
        }
        
        .batch-btn {
            padding: clamp(6px, 1vw, 10px) clamp(12px, 2vw, 20px);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: clamp(11px, 1.5vw, 14px);
            font-weight: bold;
            transition: all 0.3s;
            white-space: nowrap;
        }
        
        .batch-btn:hover {
            transform: scale(1.05);
        }
        
        .batch-btn.unequip {
            background: #32cd32;
            color: white;
        }
        
        .batch-btn.equip {
            background: #ff8c00;
            color: white;
        }
        
        .inventory-btn {
            position: absolute;
            top: clamp(10px, 2vw, 20px);
            right: clamp(15px, 3vw, 30px);
            padding: clamp(6px, 1vw, 10px) clamp(12px, 2vw, 20px);
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            font-size: clamp(11px, 1.5vw, 14px);
            z-index: 10;
            white-space: nowrap;
        }
        
        .inventory-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .hero-detail-bottom {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 45%;
            min-height: 250px;
            background: linear-gradient(to top, #8b6914 0%, #a0826d 100%);
            border-top: 3px solid #ffd700;
            padding: clamp(10px, 2vw, 20px);
            display: flex;
            gap: clamp(10px, 2vw, 20px);
            overflow-y: auto;
        }
        
        .hero-preview-section {
            width: min(250px, 30vw);
            min-width: 150px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .hero-preview-3d {
            width: min(200px, 25vw);
            height: min(200px, 25vw);
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
        }
        
        .hero-preview-platform {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 20px;
            background: radial-gradient(circle, #4a90e2 0%, #1e3a5f 100%);
            border-radius: 0 0 10px 10px;
        }
        
        .hero-info-section {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .hero-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: clamp(8px, 1.5vw, 15px);
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .hero-class-badge {
            background: #dc143c;
            color: white;
            padding: clamp(3px, 0.5vw, 5px) clamp(10px, 1.5vw, 15px);
            border-radius: 5px;
            font-weight: bold;
            font-size: clamp(12px, 2vw, 16px);
        }
        
        .hero-power {
            color: white;
            font-size: clamp(14px, 2.2vw, 18px);
            font-weight: bold;
        }
        
        .hero-level-info {
            color: white;
            font-size: clamp(12px, 2vw, 16px);
        }
        
        .hero-stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: clamp(8px, 1.5vw, 15px);
            margin-bottom: clamp(8px, 1.5vw, 15px);
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: clamp(8px, 1.5vw, 15px);
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: clamp(5px, 1vw, 10px);
        }
        
        .stat-icon {
            font-size: clamp(18px, 3vw, 24px);
        }
        
        .stat-info {
            flex: 1;
        }
        
        .stat-label-bottom {
            font-size: clamp(10px, 1.5vw, 12px);
            color: rgba(255, 255, 255, 0.7);
        }
        
        .stat-value-bottom {
            font-size: clamp(14px, 2.5vw, 20px);
            font-weight: bold;
            color: white;
        }
        
        .hero-skills-section {
            display: flex;
            gap: clamp(5px, 1vw, 10px);
            margin-top: clamp(5px, 1vw, 10px);
            flex-wrap: wrap;
        }
        
        .skill-icon {
            width: min(60px, 8vw);
            height: min(60px, 8vw);
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .skill-icon:hover {
            border-color: #ffd700;
            transform: scale(1.1);
        }
        
        .skill-level {
            font-size: 12px;
            color: #ffd700;
            margin-top: 5px;
        }
        
        .hero-actions {
            display: flex;
            gap: clamp(5px, 1vw, 10px);
            margin-top: clamp(8px, 1.5vw, 15px);
            flex-wrap: wrap;
        }
        
        .action-btn {
            padding: clamp(8px, 1.5vw, 12px) clamp(15px, 2vw, 20px);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: clamp(12px, 1.8vw, 14px);
            font-weight: bold;
            transition: all 0.3s;
            white-space: nowrap;
        }
        
        .action-btn:hover {
            transform: scale(1.05);
        }
        
        .action-btn.levelup {
            background: #ff8c00;
            color: white;
        }
        
        .action-btn.move {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .hero-detail-nav {
            position: absolute;
            bottom: clamp(10px, 2vw, 20px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: clamp(10px, 2vw, 20px);
            z-index: 10;
        }
        
        .nav-btn {
            padding: clamp(6px, 1vw, 10px) clamp(12px, 2vw, 20px);
            background: rgba(0, 0, 0, 0.5);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            font-size: clamp(11px, 1.5vw, 14px);
            white-space: nowrap;
        }
        
        .nav-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .equipment-inventory-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(600px, 90vw);
            max-height: 80vh;
            background: rgba(30, 30, 50, 0.98);
            border: 3px solid #ffd700;
            border-radius: 10px;
            padding: clamp(15px, 2vw, 20px);
            display: none;
            overflow-y: auto;
            z-index: 2000;
        }
        
        .equipment-inventory-modal.show {
            display: block;
        }
        
        .inventory-title {
            font-size: clamp(18px, 3vw, 24px);
            margin-bottom: clamp(8px, 1.5vw, 15px);
            text-align: center;
        }
        
        .inventory-item {
            padding: clamp(10px, 1.5vw, 15px);
            margin: clamp(5px, 1vw, 10px) 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        
        .inventory-item:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #ffd700;
        }
        
        .inventory-item:active {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .inventory-item-name {
            font-size: clamp(14px, 2.2vw, 18px);
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .inventory-item-stats {
            font-size: clamp(11px, 1.8vw, 14px);
            color: #87ceeb;
        }
        
        .remove-equipment-btn {
            margin-top: 10px;
            padding: 8px 15px;
            background: #dc143c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .remove-equipment-btn:hover {
            background: #ff1744;
        }
        
        .back-to-collection-btn {
            margin-bottom: clamp(10px, 2vw, 20px);
            padding: clamp(6px, 1vw, 10px) clamp(12px, 2vw, 20px);
            background: #4169e1;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: clamp(12px, 2vw, 16px);
            z-index: 100;
        }
        
        .back-to-collection-btn:hover {
            background: #5a7de8;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <!-- 인트로 화면 -->
        <div id="introScreen">
            <div class="sky-background">
                <div class="cloud cloud1"></div>
                <div class="cloud cloud2"></div>
                <div class="cloud cloud3"></div>
            </div>
            
            <!-- 챠비 캐릭터들 -->
            <div class="chibi-character chibi-1">
                <svg class="chibi-svg" viewBox="0 0 120 150">
                    <!-- 관우 스타일 -->
                    <circle cx="60" cy="40" r="28" fill="#8b4513"/>
                    <circle cx="60" cy="45" r="25" fill="#fdbcb4"/>
                    <rect x="40" y="25" width="40" height="18" fill="#228b22" rx="5"/>
                    <rect x="45" y="30" width="30" height="12" fill="#ffd700" rx="3"/>
                    <circle cx="50" cy="42" r="4" fill="#000"/>
                    <circle cx="70" cy="42" r="4" fill="#000"/>
                    <rect x="48" y="50" width="24" height="10" fill="#8b4513" rx="2"/>
                    <path d="M 35 55 Q 25 80, 20 110" stroke="#8b4513" stroke-width="5" fill="none"/>
                    <path d="M 85 55 Q 95 80, 100 110" stroke="#8b4513" stroke-width="5" fill="none"/>
                    <rect x="35" y="65" width="50" height="60" fill="#228b22" rx="5"/>
                    <rect x="40" y="70" width="40" height="15" fill="#ff0000"/>
                    <line x1="20" y1="80" x2="5" y2="100" stroke="#8b4513" stroke-width="4"/>
                </svg>
            </div>
            
            <div class="chibi-character chibi-2">
                <svg class="chibi-svg" viewBox="0 0 120 150">
                    <!-- 장비 스타일 -->
                    <circle cx="60" cy="40" r="30" fill="#8b4513"/>
                    <circle cx="60" cy="45" r="25" fill="#654321"/>
                    <rect x="40" y="25" width="40" height="18" fill="#006400" rx="5"/>
                    <rect x="45" y="30" width="30" height="12" fill="#ffd700" rx="3"/>
                    <circle cx="50" cy="42" r="5" fill="#fff"/>
                    <circle cx="70" cy="42" r="5" fill="#fff"/>
                    <circle cx="50" cy="42" r="3" fill="#000"/>
                    <circle cx="70" cy="42" r="3" fill="#000"/>
                    <ellipse cx="60" cy="55" rx="12" ry="8" fill="#000"/>
                    <path d="M 30 60 Q 20 90, 15 120" stroke="#000" stroke-width="6" fill="none"/>
                    <path d="M 90 60 Q 100 90, 105 120" stroke="#000" stroke-width="6" fill="none"/>
                    <rect x="35" y="65" width="50" height="60" fill="#006400" rx="5"/>
                    <rect x="40" y="70" width="40" height="15" fill="#ffd700"/>
                    <line x1="15" y1="85" x2="0" y2="110" stroke="#8b4513" stroke-width="5"/>
                </svg>
            </div>
            
            <div class="chibi-character chibi-3">
                <svg class="chibi-svg" viewBox="0 0 120 150">
                    <!-- 조운 스타일 -->
                    <circle cx="60" cy="40" r="28" fill="#d2b48c"/>
                    <circle cx="60" cy="45" r="25" fill="#fdbcb4"/>
                    <rect x="40" y="25" width="40" height="18" fill="#4169e1" rx="5"/>
                    <rect x="42" y="28" width="36" height="12" fill="#ffffff" rx="3"/>
                    <circle cx="50" cy="42" r="4" fill="#000"/>
                    <circle cx="70" cy="42" r="4" fill="#000"/>
                    <rect x="48" y="50" width="24" height="8" fill="#d2b48c" rx="2"/>
                    <rect x="35" y="65" width="50" height="60" fill="#4169e1" rx="5"/>
                    <rect x="40" y="70" width="40" height="12" fill="#ffffff"/>
                    <line x1="20" y1="85" x2="5" y2="110" stroke="#8b4513" stroke-width="4"/>
                </svg>
            </div>
            
            <div class="chibi-character chibi-4">
                <svg class="chibi-svg" viewBox="0 0 120 150">
                    <!-- 제갈량 스타일 -->
                    <circle cx="60" cy="40" r="28" fill="#d2b48c"/>
                    <circle cx="60" cy="45" r="25" fill="#fdbcb4"/>
                    <rect x="40" y="20" width="40" height="20" fill="#4169e1" rx="5"/>
                    <rect x="42" y="22" width="36" height="15" fill="#000080" rx="3"/>
                    <circle cx="50" cy="42" r="4" fill="#000"/>
                    <circle cx="70" cy="42" r="4" fill="#000"/>
                    <rect x="48" y="50" width="24" height="8" fill="#d2b48c" rx="2"/>
                    <path d="M 45 60 Q 35 90, 30 120" stroke="#d2b48c" stroke-width="4" fill="none"/>
                    <path d="M 75 60 Q 85 90, 90 120" stroke="#d2b48c" stroke-width="4" fill="none"/>
                    <rect x="35" y="65" width="50" height="60" fill="#87ceeb" rx="5"/>
                    <rect x="40" y="70" width="40" height="12" fill="#ffffff"/>
                    <path d="M 100 70 L 115 60 L 115 90 L 100 80 Z" fill="#ffd700"/>
                </svg>
            </div>
            
            <div class="chibi-character chibi-5">
                <svg class="chibi-svg" viewBox="0 0 120 150">
                    <!-- 여포 스타일 -->
                    <circle cx="60" cy="40" r="30" fill="#8b4513"/>
                    <circle cx="60" cy="45" r="25" fill="#654321"/>
                    <rect x="40" y="25" width="40" height="18" fill="#9370db" rx="5"/>
                    <rect x="45" y="30" width="30" height="12" fill="#ffd700" rx="3"/>
                    <rect x="48" y="38" width="24" height="10" fill="#000" rx="2"/>
                    <circle cx="50" cy="42" r="5" fill="#fff"/>
                    <circle cx="70" cy="42" r="5" fill="#fff"/>
                    <circle cx="50" cy="42" r="3" fill="#000"/>
                    <circle cx="70" cy="42" r="3" fill="#000"/>
                    <path d="M 40 60 Q 30 90, 25 120" stroke="#8b4513" stroke-width="5" fill="none"/>
                    <path d="M 80 60 Q 90 90, 95 120" stroke="#8b4513" stroke-width="5" fill="none"/>
                    <rect x="35" y="65" width="50" height="60" fill="#9370db" rx="5"/>
                    <rect x="40" y="70" width="40" height="15" fill="#ffd700"/>
                    <line x1="15" y1="85" x2="0" y2="115" stroke="#8b4513" stroke-width="6"/>
                    <path d="M 0 115 L -5 130 L 5 130 Z" fill="#ffd700"/>
                </svg>
            </div>
            
            <div class="intro-top-buttons">
                <button class="intro-top-btn">계정 변경</button>
                <button class="intro-top-btn">공지</button>
            </div>
            
            <h1 class="intro-title">삼국지 러쉬 오리진</h1>
            <p class="intro-subtitle">영웅을 모아 적을 막아라!</p>
            
            <div class="intro-buttons">
                <button class="intro-btn" onclick="startGame()">게임 시작</button>
            </div>
            
            <div class="intro-version">버전 1.0.500</div>
        </div>
        
        <canvas id="gameCanvas"></canvas>
        <div id="ui">
            <div id="topUI">
                <div id="gold">금화: <span id="goldAmount">500</span></div>
                <div id="treasure">보물: <span id="treasureAmount">0</span></div>
                <div id="round">라운드: <span id="roundNumber">1</span></div>
            </div>
            <div id="topButtons">
                <button id="heroManageButton">영웅 관리 (H)</button>
                <button id="shopButton">상점 (S)</button>
            </div>
            <div id="heroSelection"></div>
            <div id="instructions">
                <strong>조작법:</strong><br>
                숫자 키: 영웅 선택<br>
                클릭: 영웅 배치/선택<br>
                스페이스바: 스킬 사용<br>
                S: 상점, H: 영웅 관리
            </div>
        </div>
        
        <!-- 상점 모달 -->
        <div id="shopModal" class="modal">
            <h2 class="modal-title">상점</h2>
            <button class="close-btn" onclick="closeModal('shopModal')">닫기 (ESC)</button>
            <div class="shop-tabs">
                <button class="tab-btn active" onclick="switchTab('gacha')">영웅 소환</button>
                <button class="tab-btn" onclick="switchTab('consumable')">소비 아이템</button>
                <button class="tab-btn" onclick="switchTab('equipment')">장비 아이템</button>
            </div>
            <div id="gachaTab" class="tab-content">
                <div class="gacha-section">
                    <h3>영웅 소환 (가챠)</h3>
                    <p>금화 또는 보물을 사용하여 새로운 영웅을 획득할 수 있습니다.</p>
                    <div class="gacha-buttons">
                        <button class="gacha-btn single" onclick="gachaSingle()">싱글 뽑기<br>금화 1000</button>
                        <button class="gacha-btn multi" onclick="gachaMulti()">10연속 뽑기<br>금화 9000</button>
                    </div>
                    <div class="gacha-buttons" style="margin-top: 10px;">
                        <button class="gacha-btn single" onclick="gachaSingleTreasure()">고급 뽑기<br>보물 10</button>
                        <button class="gacha-btn multi" onclick="gachaMultiTreasure()">전설 10연속<br>보물 90</button>
                    </div>
                    <div id="gachaResult" class="gacha-result"></div>
                </div>
            </div>
            <div id="consumableTab" class="tab-content" style="display: none;">
                <div id="consumableItems"></div>
            </div>
            <div id="equipmentTab" class="tab-content" style="display: none;">
                <div id="equipmentItems"></div>
            </div>
        </div>
        
        <!-- 영웅 관리 모달 -->
        <div id="heroManageModal" class="modal">
            <h2 class="modal-title">영웅 관리</h2>
            <button class="close-btn" onclick="closeModal('heroManageModal')">닫기 (ESC)</button>
            <div id="heroCollectionView">
                <div class="hero-collection" id="heroCollection"></div>
            </div>
            <div id="heroDetailView" style="display: none;">
                <button class="back-to-collection-btn" onclick="showCollectionView()" style="position: absolute; top: 10px; left: 10px; z-index: 100;">← 영웅 목록으로</button>
                <div class="hero-detail-container">
                    <!-- 상단 영역: 큰 캐릭터 일러스트 -->
                    <div class="hero-detail-top">
                        <!-- 상단 정보 -->
                        <div class="hero-top-info">
                            <div class="hero-badge">
                                <span>무쌍</span>
                                <span class="hero-badge-stars">★★</span>
                            </div>
                            <div>
                                <div class="hero-name-top" id="heroDetailNameTop">관우</div>
                                <div class="hero-star-slots" id="heroStarSlots"></div>
                            </div>
                        </div>
                        
                        <!-- 큰 캐릭터 일러스트 -->
                        <div class="hero-illustration-large" id="heroIllustrationLarge">
                            <!-- 동적으로 업데이트됨 -->
                        </div>
                        
                        <!-- 좌측 장비 슬롯 -->
                        <div class="equipment-slots-side equipment-slots-left" id="equipmentSlotsLeft"></div>
                        
                        <!-- 우측 장비 슬롯 -->
                        <div class="equipment-slots-side equipment-slots-right" id="equipmentSlotsRight"></div>
                        
                        <!-- 좌측 일괄 버튼 -->
                        <div class="equipment-batch-buttons left">
                            <button class="batch-btn unequip" onclick="unequipAllEquipment(currentDetailHeroType)">일괄 해제</button>
                        </div>
                        
                        <!-- 우측 일괄 버튼 -->
                        <div class="equipment-batch-buttons right">
                            <button class="batch-btn equip" onclick="equipBestEquipment(currentDetailHeroType)">일괄 장착</button>
                        </div>
                        
                        <!-- 장부 버튼 -->
                        <button class="inventory-btn" onclick="showFullInventory()">장부</button>
                    </div>
                    
                    <!-- 하단 영역: 정보 패널 -->
                    <div class="hero-detail-bottom">
                        <!-- 왼쪽: 캐릭터 미리보기 -->
                        <div class="hero-preview-section">
                            <div class="hero-preview-3d">
                                <div style="font-size: 100px;">⚔️</div>
                                <div class="hero-preview-platform"></div>
                            </div>
                        </div>
                        
                        <!-- 오른쪽: 능력치 및 스킬 -->
                        <div class="hero-info-section">
                            <div class="hero-info-header">
                                <div>
                                    <span class="hero-class-badge" id="heroClassBadge">절</span>
                                    <span class="hero-power" id="heroPower">전투력 214만</span>
                                </div>
                                <div class="hero-level-info" id="heroLevelInfo">레벨 773/860</div>
                            </div>
                            
                            <div class="hero-stats-grid">
                                <div class="stat-box">
                                    <div class="stat-icon">⚔️</div>
                                    <div class="stat-info">
                                        <div class="stat-label-bottom">공격력</div>
                                        <div class="stat-value-bottom" id="heroStatAttack">252334</div>
                                    </div>
                                </div>
                                <div class="stat-box">
                                    <div class="stat-icon">🛡️</div>
                                    <div class="stat-info">
                                        <div class="stat-label-bottom">방어력</div>
                                        <div class="stat-value-bottom" id="heroStatDefense">95195</div>
                                    </div>
                                </div>
                                <div class="stat-box">
                                    <div class="stat-icon">❤️</div>
                                    <div class="stat-info">
                                        <div class="stat-label-bottom">체력</div>
                                        <div class="stat-value-bottom" id="heroStatHealth">5288146</div>
                                    </div>
                                </div>
                                <div class="stat-box">
                                    <div class="stat-icon">⚡</div>
                                    <div class="stat-info">
                                        <div class="stat-label-bottom">공격 속도</div>
                                        <div class="stat-value-bottom" id="heroStatSpeed">1.1</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="hero-actions">
                                <button class="action-btn move" onclick="moveToCommandPost()">통솔부로 이동</button>
                                <button class="action-btn levelup" onclick="levelUpHero(currentDetailHeroType)">레벨업</button>
                            </div>
                            
                            <div class="hero-skills-section" id="heroSkillsSection">
                                <!-- 스킬 아이콘들이 여기에 동적으로 추가됨 -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- 하단 네비게이션 -->
                    <div class="hero-detail-nav">
                        <button class="nav-btn" onclick="showCollectionView()">뒤로</button>
                        <button class="nav-btn">스킨</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 장비 인벤토리 모달 -->
        <div id="equipmentInventoryModal" class="equipment-inventory-modal">
            <h3 class="inventory-title" id="inventoryTitle">장비 선택</h3>
            <button class="close-btn" onclick="closeEquipmentInventory()">닫기</button>
            <div id="equipmentInventoryList"></div>
        </div>
    </div>

    <script>
        // 게임 상수 (기본값, 반응형으로 조정됨)
        let CANVAS_WIDTH = 1200;
        let CANVAS_HEIGHT = 800;
        const FPS = 60;
        const ASPECT_RATIO = 1200 / 800; // 3:2 비율

        // 색상 정의
        const COLORS = {
            WHITE: '#FFFFFF',
            BLACK: '#000000',
            RED: '#FF0000',
            GREEN: '#00FF00',
            BLUE: '#0000FF',
            YELLOW: '#FFFF00',
            GOLD: '#FFD700',
            PURPLE: '#9370DB',
            ORANGE: '#FFA500',
            CYAN: '#00FFFF',
            MAGENTA: '#FF00FF'
        };

        // 등급 정의
        const HeroGrade = {
            N: 'N',
            R: 'R',
            SR: 'SR',
            SSR: 'SSR'
        };

        // 게임 상태
        let gameState = 'MENU';
        let gold = 500;
        let treasure = 0;
        let roundNum = 1;
        let enemies = [];
        let heroes = [];
        let effects = [];
        let selectedHero = null;
        let placingHeroType = null;
        let waveTimer = 0;
        let waveInterval = 2.0;
        let enemiesSpawned = 0;
        let enemiesPerWave = 5;
        let gameOver = false;
        let victory = false;

        // 영웅 카드 보관함 (영웅 타입 -> 등급 -> 개수)
        let heroCollection = {};
        // 영웅 강화 정보 (영웅 타입 -> 별 등급)
        let heroStars = {};
        // 장비 인벤토리 (장비 ID -> 개수)
        let equipmentInventory = {};
        // 영웅 장비 (영웅 타입 -> 장비 슬롯 -> 장비 ID)
        let heroEquipment = {};
        
        // 장비 타입 정의
        const EquipmentType = {
            WEAPON: 'weapon',
            ARMOR: 'armor',
            HELMET: 'helmet',
            ACCESSORY: 'accessory'
        };
        
        // 장비 슬롯 정의
        const EquipmentSlots = [
            { type: EquipmentType.WEAPON, name: '무기', icon: '⚔️' },
            { type: EquipmentType.ARMOR, name: '갑옷', icon: '🛡️' },
            { type: EquipmentType.HELMET, name: '투구', icon: '⛑️' },
            { type: EquipmentType.ACCESSORY, name: '장신구', icon: '💍' }
        ];
        
        // 장비 데이터베이스
        const equipmentDatabase = {
            // 무기
            'sword_basic': { name: '기본 검', type: EquipmentType.WEAPON, attack: 10, costGold: 300 },
            'sword_iron': { name: '철검', type: EquipmentType.WEAPON, attack: 20, costGold: 500 },
            'sword_steel': { name: '강철검', type: EquipmentType.WEAPON, attack: 35, costGold: 800 },
            'sword_legendary': { name: '전설의 검', type: EquipmentType.WEAPON, attack: 50, attackSpeed: 0.15, costTreasure: 5 },
            'spear_basic': { name: '기본 창', type: EquipmentType.WEAPON, attack: 12, range: 0.1, costGold: 350 },
            'spear_legendary': { name: '청룡언월도', type: EquipmentType.WEAPON, attack: 60, range: 0.2, costTreasure: 8 },
            
            // 갑옷
            'armor_basic': { name: '기본 갑옷', type: EquipmentType.ARMOR, health: 50, costGold: 300 },
            'armor_iron': { name: '철갑옷', type: EquipmentType.ARMOR, health: 100, costGold: 500 },
            'armor_steel': { name: '강철갑옷', type: EquipmentType.ARMOR, health: 180, costGold: 800 },
            'armor_legendary': { name: '전설의 갑옷', type: EquipmentType.ARMOR, health: 300, defense: 0.4, costTreasure: 5 },
            
            // 투구
            'helmet_basic': { name: '기본 투구', type: EquipmentType.HELMET, health: 30, costGold: 200 },
            'helmet_iron': { name: '철투구', type: EquipmentType.HELMET, health: 60, costGold: 400 },
            'helmet_legendary': { name: '전설의 투구', type: EquipmentType.HELMET, health: 150, attackSpeed: 0.1, costTreasure: 4 },
            
            // 장신구
            'ring_attack': { name: '공격 반지', type: EquipmentType.ACCESSORY, attack: 15, attackSpeed: 0.1, costGold: 500 },
            'ring_range': { name: '범위 확장 부적', type: EquipmentType.ACCESSORY, range: 0.3, costGold: 400 },
            'ring_crit': { name: '치명타 반지', type: EquipmentType.ACCESSORY, critChance: 0.2, costGold: 500 },
            'ring_legendary': { name: '전설의 장신구', type: EquipmentType.ACCESSORY, attack: 25, attackSpeed: 0.15, range: 0.2, costTreasure: 6 }
        };

        // Canvas 설정
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 반응형 Canvas 크기 조정 함수
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // 컨테이너 비율에 맞춰 Canvas 크기 결정
            const containerRatio = containerWidth / containerHeight;
            
            if (containerRatio > ASPECT_RATIO) {
                // 컨테이너가 더 넓음 - 높이 기준
                CANVAS_HEIGHT = containerHeight;
                CANVAS_WIDTH = CANVAS_HEIGHT * ASPECT_RATIO;
            } else {
                // 컨테이너가 더 높음 - 너비 기준
                CANVAS_WIDTH = containerWidth;
                CANVAS_HEIGHT = CANVAS_WIDTH / ASPECT_RATIO;
            }
            
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            
            // Canvas 스타일 크기 설정 (CSS로 표시 크기 조정)
            canvas.style.width = CANVAS_WIDTH + 'px';
            canvas.style.height = CANVAS_HEIGHT + 'px';
        }
        
        // 초기 크기 설정
        resizeCanvas();
        
        // 화면 크기 변경 시 재조정
        window.addEventListener('resize', () => {
            resizeCanvas();
        });

        // 유닛 타입
        const UnitType = {
            SOLDIER: '병사',
            ARCHER: '궁수',
            CAVALRY: '기마병',
            SPEARMAN: '창병',
            DRAGON: '비룡',
            SHIELDMAN: '방패병',
            BOSS: '보스'
        };

        // 영웅 타입
        const HeroType = {
            GUANYU: 0,
            ZHUGELIANG: 1,
            ZHANGFEI: 2,
            ZHAOYUN: 3,
            LIUBEI: 4,
            LUBU: 5,
            // 위(魏)
            CAOCAO: 6,
            XIAHOUDUN: 7,
            ZHANGLIAO: 8,
            XUZHU: 9,
            XIAHOUYUAN: 10,
            XUHuang: 11,
            XUCHU: 12,
            YUJIN: 13,
            YUEJIN: 14,
            ZHANGHE: 15,
            WENCHOU: 16,
            YANLIANG: 17,
            // 촉(蜀)
            HUANGZHONG: 18,
            MACHAO: 19,
            WEIYAN: 20,
            JIANGWEI: 21,
            GUANPING: 22,
            GUANXING: 23,
            ZHANGBao: 24,
            MA_DAI: 25,
            // 오(吳)
            SUNQUAN: 26,
            ZHUYU: 27,
            GANNING: 28,
            TAISHICI: 29,
            LUMENG: 30,
            LUXUN: 31,
            SUNCE: 32,
            ZHOUTAI: 33,
            CHENGPU: 34,
            HUANGGAI: 35
        };

        const HeroNames = [
            '관우', '제갈량', '장비', '조운', '유비', '여포',
            // 위(魏)
            '조조', '하후돈', '장료', '허저', '하후연', '서황', '악진', '우금', '장합', '문추', '안량',
            // 촉(蜀)
            '황충', '마초', '위연', '강유', '관평', '관흥', '장포', '마대',
            // 오(吳)
            '손권', '주유', '감녕', '태사자', '여몽', '육손', '손책', '주태', '정봉', '황개'
        ];
        const HeroColors = [
            COLORS.GREEN, COLORS.BLUE, COLORS.RED, COLORS.YELLOW, COLORS.GOLD, COLORS.PURPLE,
            // 위(魏) - 빨간 계열
            '#8b0000', '#dc143c', '#ff6347', '#ff4500', '#b22222', '#cd5c5c', '#ff1493', '#c71585', '#8b008b', '#9932cc', '#9370db',
            // 촉(蜀) - 주황/금색 계열
            '#ffa500', '#ff8c00', '#daa520', '#ffd700', '#ffb347', '#ffa07a', '#ff7f50', '#ff6347',
            // 오(吳) - 파란 계열
            '#4169e1', '#1e90ff', '#00bfff', '#87ceeb', '#4682b4', '#5f9ea0', '#00ced1', '#20b2aa', '#48d1cc', '#40e0d0'
        ];

        // 가챠 확률 설정
        const gachaRates = {
            normal: { N: 0.5, R: 0.35, SR: 0.13, SSR: 0.02 },
            premium: { N: 0.3, R: 0.4, SR: 0.25, SSR: 0.05 }
        };

        // 영웅 등급 매핑 (각 영웅의 기본 등급)
        const heroBaseGrade = {
            [HeroType.GUANYU]: HeroGrade.SSR,
            [HeroType.ZHUGELIANG]: HeroGrade.SSR,
            [HeroType.ZHANGFEI]: HeroGrade.SR,
            [HeroType.ZHAOYUN]: HeroGrade.SR,
            [HeroType.LIUBEI]: HeroGrade.R,
            [HeroType.LUBU]: HeroGrade.SSR,
            // 위(魏)
            [HeroType.CAOCAO]: HeroGrade.SSR,
            [HeroType.XIAHOUDUN]: HeroGrade.SR,
            [HeroType.ZHANGLIAO]: HeroGrade.SR,
            [HeroType.XUZHU]: HeroGrade.R,
            // 촉(蜀)
            [HeroType.HUANGZHONG]: HeroGrade.SR,
            [HeroType.MACHAO]: HeroGrade.SR,
            [HeroType.WEIYAN]: HeroGrade.R,
            // 오(吳)
            [HeroType.SUNQUAN]: HeroGrade.SSR,
            [HeroType.ZHUYU]: HeroGrade.SSR,
            [HeroType.GANNING]: HeroGrade.SR,
            [HeroType.TAISHICI]: HeroGrade.SR
        };

        // 가챠 함수
        function getRandomGrade(rates) {
            const rand = Math.random();
            let cumulative = 0;
            for (const [grade, rate] of Object.entries(rates)) {
                cumulative += rate;
                if (rand <= cumulative) {
                    return grade;
                }
            }
            return HeroGrade.N;
        }

        function getRandomHero(grade) {
            // 등급에 맞는 영웅 선택
            const heroesByGrade = {
                [HeroGrade.N]: [HeroType.LIUBEI, HeroType.WEIYAN, HeroType.XUHuang, HeroType.YUJIN, HeroType.YUEJIN, HeroType.GUANPING, HeroType.GUANXING, HeroType.ZHANGBao, HeroType.MA_DAI, HeroType.CHENGPU],
                [HeroGrade.R]: [HeroType.LIUBEI, HeroType.ZHANGFEI, HeroType.XUZHU, HeroType.WEIYAN, HeroType.XUHuang, HeroType.YUJIN, HeroType.YUEJIN, HeroType.GUANPING, HeroType.GUANXING, HeroType.ZHANGBao, HeroType.MA_DAI, HeroType.CHENGPU],
                [HeroGrade.SR]: [HeroType.ZHANGFEI, HeroType.ZHAOYUN, HeroType.XIAHOUDUN, HeroType.ZHANGLIAO, HeroType.HUANGZHONG, HeroType.MACHAO, HeroType.GANNING, HeroType.TAISHICI, HeroType.XIAHOUYUAN, HeroType.XUCHU, HeroType.ZHANGHE, HeroType.WENCHOU, HeroType.YANLIANG, HeroType.JIANGWEI, HeroType.LUMENG, HeroType.ZHOUTAI, HeroType.HUANGGAI],
                [HeroGrade.SSR]: [HeroType.GUANYU, HeroType.ZHUGELIANG, HeroType.LUBU, HeroType.CAOCAO, HeroType.SUNQUAN, HeroType.ZHUYU, HeroType.LUXUN, HeroType.SUNCE]
            };
            
            const availableHeroes = heroesByGrade[grade] || [HeroType.LIUBEI];
            return availableHeroes[Math.floor(Math.random() * availableHeroes.length)];
        }

        function addHeroCard(heroType, grade) {
            if (!heroCollection[heroType]) {
                heroCollection[heroType] = {};
            }
            if (!heroCollection[heroType][grade]) {
                heroCollection[heroType][grade] = 0;
            }
            heroCollection[heroType][grade]++;
            updateHeroCollection();
            updateHeroSelection();
        }

        function gachaSingle() {
            if (gold < 1000) {
                alert('금화가 부족합니다!');
                return;
            }
            gold -= 1000;
            const grade = getRandomGrade(gachaRates.normal);
            const heroType = getRandomHero(grade);
            addHeroCard(heroType, grade);
            showGachaResult([{ heroType, grade }]);
            updateUI();
        }

        function gachaMulti() {
            if (gold < 9000) {
                alert('금화가 부족합니다!');
                return;
            }
            gold -= 9000;
            const results = [];
            for (let i = 0; i < 10; i++) {
                const grade = getRandomGrade(gachaRates.normal);
                const heroType = getRandomHero(grade);
                addHeroCard(heroType, grade);
                results.push({ heroType, grade });
            }
            showGachaResult(results);
            updateUI();
        }

        function gachaSingleTreasure() {
            if (treasure < 10) {
                alert('보물이 부족합니다!');
                return;
            }
            treasure -= 10;
            const grade = getRandomGrade(gachaRates.premium);
            const heroType = getRandomHero(grade);
            addHeroCard(heroType, grade);
            showGachaResult([{ heroType, grade }]);
            updateUI();
        }

        function gachaMultiTreasure() {
            if (treasure < 90) {
                alert('보물이 부족합니다!');
                return;
            }
            treasure -= 90;
            const results = [];
            for (let i = 0; i < 10; i++) {
                const grade = getRandomGrade(gachaRates.premium);
                const heroType = getRandomHero(grade);
                addHeroCard(heroType, grade);
                results.push({ heroType, grade });
            }
            showGachaResult(results);
            updateUI();
        }

        function showGachaResult(results) {
            const resultDiv = document.getElementById('gachaResult');
            resultDiv.innerHTML = '<h3>뽑기 결과:</h3>';
            results.forEach(result => {
                const card = document.createElement('div');
                card.className = `hero-card ${result.grade}`;
                card.innerHTML = `
                    <div class="hero-card-grade">${result.grade}</div>
                    <div class="hero-card-name">${HeroNames[result.heroType]}</div>
                `;
                resultDiv.appendChild(card);
            });
            resultDiv.classList.add('show');
            setTimeout(() => {
                resultDiv.classList.remove('show');
            }, 5000);
        }

        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.style.display = 'none');
            
            event.target.classList.add('active');
            if (tabName === 'gacha') {
                document.getElementById('gachaTab').style.display = 'block';
            } else if (tabName === 'consumable') {
                document.getElementById('consumableTab').style.display = 'block';
            } else if (tabName === 'equipment') {
                document.getElementById('equipmentTab').style.display = 'block';
            }
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }

        // 영웅 강화 함수
        function enhanceHero(heroType) {
            if (!heroStars[heroType]) {
                heroStars[heroType] = 1;
            }
            
            const currentStars = heroStars[heroType];
            if (currentStars >= 6) {
                alert('이미 최대 등급입니다!');
                return;
            }
            
            // 필요한 카드 수 (현재 별 등급 + 1)
            const requiredCards = currentStars + 1;
            const totalCards = getTotalHeroCards(heroType);
            
            if (totalCards < requiredCards) {
                alert(`강화에 필요한 카드가 부족합니다! (필요: ${requiredCards}개, 보유: ${totalCards}개)`);
                return;
            }
            
            // 카드 소모
            consumeHeroCards(heroType, requiredCards);
            heroStars[heroType]++;
            updateHeroCollection();
            alert(`${HeroNames[heroType]}이(가) ${currentStars}성에서 ${heroStars[heroType]}성으로 승급했습니다!`);
        }

        function getTotalHeroCards(heroType) {
            if (!heroCollection[heroType]) return 0;
            let total = 0;
            for (const count of Object.values(heroCollection[heroType])) {
                total += count;
            }
            return total;
        }

        function consumeHeroCards(heroType, amount) {
            if (!heroCollection[heroType]) return;
            
            let remaining = amount;
            const grades = [HeroGrade.N, HeroGrade.R, HeroGrade.SR, HeroGrade.SSR];
            
            for (const grade of grades) {
                if (remaining <= 0) break;
                if (heroCollection[heroType][grade]) {
                    const consume = Math.min(remaining, heroCollection[heroType][grade]);
                    heroCollection[heroType][grade] -= consume;
                    remaining -= consume;
                    if (heroCollection[heroType][grade] === 0) {
                        delete heroCollection[heroType][grade];
                    }
                }
            }
        }

        function updateHeroCollection() {
            const collectionDiv = document.getElementById('heroCollection');
            collectionDiv.innerHTML = '';
            
            for (let heroType = 0; heroType < HeroNames.length; heroType++) {
                const totalCards = getTotalHeroCards(heroType);
                const stars = heroStars[heroType] || 1;
                const highestGrade = getHighestGrade(heroType);
                
                if (totalCards === 0 && stars === 1) continue;
                
                const card = document.createElement('div');
                card.className = `collection-card ${highestGrade || HeroGrade.N}`;
                
                const requiredCards = stars + 1;
                const canEnhance = totalCards >= requiredCards && stars < 6;
                
                const illustrationFunctions = [
                    getGuanYuIllustration,
                    getZhugeLiangIllustration,
                    getZhangFeiIllustration,
                    getZhaoYunIllustration,
                    getLiuBeiIllustration,
                    getLuBuIllustration
                ];
                
                const illustration = illustrationFunctions[heroType] ? illustrationFunctions[heroType]() : '';
                
                card.innerHTML = `
                    <div class="card-header">
                        <div class="card-name">${HeroNames[heroType]}</div>
                        <div class="card-count">보유: ${totalCards}</div>
                    </div>
                    <div class="card-illustration" style="width: 100%; height: 150px; margin: 10px 0; display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05)); border-radius: 10px; overflow: hidden;">
                        ${illustration.replace('viewBox="0 0 300 400"', 'viewBox="0 0 300 400" style="width: 100%; max-height: 150px;"')}
                    </div>
                    <div class="star-rating">${'★'.repeat(stars)}${'☆'.repeat(6 - stars)}</div>
                    <div style="margin-top: 10px; font-size: 12px;">
                        등급: ${highestGrade || 'N'}
                    </div>
                    <button class="enhance-btn" ${!canEnhance ? 'disabled' : ''} 
                            onclick="enhanceHero(${heroType})">
                        ${stars >= 6 ? '최대 등급' : `승급 (필요: ${requiredCards}개)`}
                    </button>
                    <button class="enhance-btn" style="background: #4169e1; margin-top: 5px;" 
                            onclick="showHeroDetail(${heroType})">
                        상세 정보
                    </button>
                `;
                
                collectionDiv.appendChild(card);
            }
        }
        
        function showCollectionView() {
            document.getElementById('heroCollectionView').style.display = 'block';
            document.getElementById('heroDetailView').style.display = 'none';
        }
        
        let currentDetailHeroType = null;
        
        function showHeroDetail(heroType) {
            currentDetailHeroType = heroType;
            document.getElementById('heroCollectionView').style.display = 'none';
            document.getElementById('heroDetailView').style.display = 'block';
            
            const stars = heroStars[heroType] || 1;
            const baseStats = [
                { attack: 50, attackSpeed: 1.0, range: 150, health: 500 }, // 관우
                { attack: 40, attackSpeed: 0.8, range: 200, health: 400 }, // 제갈량
                { attack: 60, attackSpeed: 1.2, range: 120, health: 600 }, // 장비
                { attack: 55, attackSpeed: 1.5, range: 130, health: 450 }, // 조운
                { attack: 45, attackSpeed: 1.0, range: 140, health: 500 }, // 유비
                { attack: 70, attackSpeed: 1.3, range: 140, health: 550 }, // 여포
                // 위(魏)
                { attack: 65, attackSpeed: 1.1, range: 160, health: 520 }, // 조조
                { attack: 58, attackSpeed: 1.3, range: 130, health: 580 }, // 하후돈
                { attack: 56, attackSpeed: 1.4, range: 145, health: 540 }, // 장료
                { attack: 62, attackSpeed: 1.0, range: 125, health: 650 }, // 허저
                { attack: 57, attackSpeed: 1.2, range: 135, health: 560 }, // 하후연
                { attack: 54, attackSpeed: 1.1, range: 140, health: 550 }, // 서황
                { attack: 60, attackSpeed: 1.3, range: 132, health: 570 }, // 악진
                { attack: 55, attackSpeed: 1.0, range: 128, health: 600 }, // 우금
                { attack: 59, attackSpeed: 1.4, range: 143, health: 545 }, // 장합
                { attack: 61, attackSpeed: 1.2, range: 130, health: 575 }, // 문추
                { attack: 63, attackSpeed: 1.1, range: 127, health: 590 }, // 안량
                // 촉(蜀)
                { attack: 52, attackSpeed: 0.9, range: 180, health: 480 }, // 황충
                { attack: 64, attackSpeed: 1.4, range: 135, health: 530 }, // 마초
                { attack: 48, attackSpeed: 1.2, range: 140, health: 490 }, // 위연
                { attack: 53, attackSpeed: 1.0, range: 165, health: 470 }, // 강유
                { attack: 46, attackSpeed: 1.1, range: 145, health: 485 }, // 관평
                { attack: 47, attackSpeed: 1.2, range: 142, health: 495 }, // 관흥
                { attack: 49, attackSpeed: 1.3, range: 138, health: 505 }, // 장포
                { attack: 50, attackSpeed: 1.1, range: 140, health: 500 }, // 마대
                // 오(吳)
                { attack: 50, attackSpeed: 1.0, range: 155, health: 510 }, // 손권
                { attack: 42, attackSpeed: 0.9, range: 190, health: 420 }, // 주유
                { attack: 59, attackSpeed: 1.3, range: 138, health: 520 }, // 감녕
                { attack: 57, attackSpeed: 1.5, range: 142, health: 500 }, // 태사자
                { attack: 58, attackSpeed: 1.2, range: 148, health: 515 }, // 여몽
                { attack: 44, attackSpeed: 0.85, range: 185, health: 430 }, // 육손
                { attack: 66, attackSpeed: 1.4, range: 152, health: 540 }, // 손책
                { attack: 56, attackSpeed: 1.1, range: 136, health: 525 }, // 주태
                { attack: 48, attackSpeed: 1.0, range: 144, health: 490 }, // 정봉
                { attack: 55, attackSpeed: 0.95, range: 150, health: 580 }  // 황개
            ];
            
            const stats = baseStats[heroType] || baseStats[0];
            const starMultiplier = 1 + (stars - 1) * 0.2;
            
            let baseAttack = Math.floor(stats.attack * starMultiplier);
            let baseAttackSpeed = stats.attackSpeed * (1 + (stars - 1) * 0.1);
            let baseRange = Math.floor(stats.range * (1 + (stars - 1) * 0.1));
            let baseHealth = Math.floor(stats.health * starMultiplier);
            
            // 장비 보정 계산
            const equipment = heroEquipment[heroType] || {};
            let finalAttack = baseAttack;
            let finalAttackSpeed = baseAttackSpeed;
            let finalRange = baseRange;
            let finalHealth = baseHealth;
            
            for (const slot in equipment) {
                const equipId = equipment[slot];
                if (equipId && equipmentDatabase[equipId]) {
                    const equip = equipmentDatabase[equipId];
                    if (equip.attack) finalAttack += equip.attack;
                    if (equip.attackSpeed) finalAttackSpeed *= (1 + equip.attackSpeed);
                    if (equip.range) finalRange = Math.floor(finalRange * (1 + equip.range));
                    if (equip.health) finalHealth += equip.health;
                }
            }
            
            // 전투력 계산 (간단한 공식)
            const combatPower = Math.floor((finalAttack * 10 + finalHealth + finalRange * 5) / 1000);
            
            // 상단 정보 업데이트
            document.getElementById('heroDetailNameTop').textContent = HeroNames[heroType];
            const starSlotsDiv = document.getElementById('heroStarSlots');
            starSlotsDiv.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const slot = document.createElement('div');
                slot.className = `star-slot ${i < stars ? 'filled' : ''}`;
                starSlotsDiv.appendChild(slot);
            }
            
            // 캐릭터 일러스트 업데이트
            updateHeroIllustration(heroType);
            
            // 하단 정보 업데이트
            document.getElementById('heroPower').textContent = `전투력 ${combatPower}만`;
            document.getElementById('heroLevelInfo').textContent = `레벨 ${stars * 100 + 73}/${stars * 100 + 160}`;
            document.getElementById('heroStatAttack').textContent = finalAttack.toLocaleString();
            document.getElementById('heroStatDefense').textContent = Math.floor(finalHealth * 0.18).toLocaleString();
            document.getElementById('heroStatHealth').textContent = finalHealth.toLocaleString();
            document.getElementById('heroStatSpeed').textContent = finalAttackSpeed.toFixed(1);
            
            // 장비 슬롯 업데이트 (좌우 배치)
            const slotsLeftDiv = document.getElementById('equipmentSlotsLeft');
            const slotsRightDiv = document.getElementById('equipmentSlotsRight');
            slotsLeftDiv.innerHTML = '';
            slotsRightDiv.innerHTML = '';
            
            // 좌측: 무기, 갑옷
            const leftSlots = [EquipmentSlots[0], EquipmentSlots[1]];
            leftSlots.forEach(slot => {
                const slotDiv = createEquipmentSlotSide(heroType, slot);
                slotsLeftDiv.appendChild(slotDiv);
            });
            
            // 우측: 투구, 장신구
            const rightSlots = [EquipmentSlots[2], EquipmentSlots[3]];
            rightSlots.forEach(slot => {
                const slotDiv = createEquipmentSlotSide(heroType, slot);
                slotsRightDiv.appendChild(slotDiv);
            });
            
            // 스킬 섹션 업데이트
            updateSkillsSection(heroType);
        }
        
        function createEquipmentSlotSide(heroType, slot) {
            const slotDiv = document.createElement('div');
            slotDiv.className = 'equipment-slot-side';
            const equipment = heroEquipment[heroType] || {};
            const equippedId = equipment[slot.type];
            const equipped = equippedId && equipmentDatabase[equippedId];
            
            if (equipped) {
                slotDiv.classList.add('equipped');
            }
            
            slotDiv.innerHTML = `
                <div class="equipment-slot-icon">${slot.icon}</div>
                ${equipped ? `<div class="equipment-slot-stars">${'★'.repeat(5)}</div>` : ''}
            `;
            
            slotDiv.addEventListener('click', () => {
                showEquipmentInventory(heroType, slot.type);
            });
            
            return slotDiv;
        }
        
        function updateHeroIllustration(heroType) {
            const illustrationDiv = document.getElementById('heroIllustrationLarge');
            
            const heroIllustrations = {
                0: getGuanYuIllustration(),      // 관우
                1: getZhugeLiangIllustration(), // 제갈량
                2: getZhangFeiIllustration(),   // 장비
                3: getZhaoYunIllustration(),    // 조운
                4: getLiuBeiIllustration(),      // 유비
                5: getLuBuIllustration(),        // 여포
                // 위(魏)
                6: getCaoCaoIllustration(),      // 조조
                7: getXiahouDunIllustration(),   // 하후돈
                8: getZhangLiaoIllustration(),   // 장료
                9: getXuZhuIllustration(),       // 허저
                10: getXiahouDunIllustration(),  // 하후연
                11: getZhangLiaoIllustration(),  // 서황
                12: getXuZhuIllustration(),      // 악진
                13: getXiahouDunIllustration(),  // 우금
                14: getZhangLiaoIllustration(),  // 장합
                15: getXiahouDunIllustration(),  // 문추
                16: getXuZhuIllustration(),     // 안량
                17: getXiahouDunIllustration(),  // 안량
                // 촉(蜀)
                18: getHuangZhongIllustration(), // 황충
                19: getMaChaoIllustration(),     // 마초
                20: getWeiYanIllustration(),     // 위연
                21: getZhugeLiangIllustration(), // 강유
                22: getGuanYuIllustration(),     // 관평
                23: getGuanYuIllustration(),     // 관흥
                24: getZhangFeiIllustration(),   // 장포
                25: getMaChaoIllustration(),     // 마대
                // 오(吳)
                26: getSunQuanIllustration(),    // 손권
                27: getZhuYuIllustration(),      // 주유
                28: getGanNingIllustration(),    // 감녕
                29: getTaiShiCiIllustration(),   // 태사자
                30: getZhuYuIllustration(),      // 여몽
                31: getZhugeLiangIllustration(), // 육손
                32: getSunQuanIllustration(),    // 손책
                33: getGanNingIllustration(),    // 주태
                34: getTaiShiCiIllustration(),   // 정봉
                35: getTaiShiCiIllustration()   // 황개
            };
            
            illustrationDiv.innerHTML = heroIllustrations[heroType] || heroIllustrations[0];
        }
        
        function getGuanYuIllustration() {
            return `
                <svg viewBox="0 0 300 400" style="width: 100%; height: auto;">
                    <!-- 배경 효과 -->
                    <defs>
                        <linearGradient id="guanYuGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#228b22;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#006400;stop-opacity:1" />
                        </linearGradient>
                        <filter id="glow">
                            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                            <feMerge>
                                <feMergeNode in="coloredBlur"/>
                                <feMergeNode in="SourceGraphic"/>
                            </feMerge>
                        </filter>
                    </defs>
                    
                    <!-- 긴 수염 -->
                    <path d="M 80 120 Q 70 160, 60 200 Q 70 240, 80 280" stroke="#8b4513" stroke-width="8" fill="none" stroke-linecap="round"/>
                    <path d="M 120 120 Q 130 160, 140 200 Q 130 240, 120 280" stroke="#8b4513" stroke-width="8" fill="none" stroke-linecap="round"/>
                    
                    <!-- 머리 -->
                    <circle cx="150" cy="100" r="55" fill="#8b4513"/>
                    <circle cx="150" cy="105" r="48" fill="#fdbcb4"/>
                    
                    <!-- 관우 모자 -->
                    <path d="M 100 80 L 200 80 L 190 60 L 110 60 Z" fill="#228b22"/>
                    <path d="M 110 60 L 190 60 L 185 50 L 115 50 Z" fill="#ffd700"/>
                    <circle cx="150" cy="55" r="8" fill="#ff0000"/>
                    
                    <!-- 눈썹 (두꺼운) -->
                    <rect x="120" y="85" width="25" height="8" fill="#8b4513" rx="4"/>
                    <rect x="155" y="85" width="25" height="8" fill="#8b4513" rx="4"/>
                    
                    <!-- 눈 -->
                    <circle cx="135" cy="100" r="5" fill="#000"/>
                    <circle cx="165" cy="100" r="5" fill="#000"/>
                    <circle cx="137" cy="98" r="2" fill="#fff"/>
                    <circle cx="167" cy="98" r="2" fill="#fff"/>
                    
                    <!-- 입 -->
                    <path d="M 140 115 Q 150 120, 160 115" stroke="#8b4513" stroke-width="3" fill="none"/>
                    
                    <!-- 갑옷 상체 -->
                    <path d="M 80 150 Q 80 140, 100 135 L 200 135 Q 220 140, 220 150 L 220 220 Q 220 230, 200 235 L 100 235 Q 80 230, 80 220 Z" fill="url(#guanYuGrad)"/>
                    <rect x="100" y="145" width="100" height="25" fill="#ff0000" rx="5"/>
                    <rect x="110" y="150" width="80" height="15" fill="#ffd700" rx="3"/>
                    
                    <!-- 어깨 갑옷 -->
                    <ellipse cx="90" cy="160" rx="20" ry="15" fill="#228b22"/>
                    <ellipse cx="210" cy="160" rx="20" ry="15" fill="#228b22"/>
                    
                    <!-- 팔 -->
                    <rect x="60" y="155" width="30" height="80" fill="#228b22" rx="8"/>
                    <rect x="210" y="155" width="30" height="80" fill="#228b22" rx="8"/>
                    
                    <!-- 청룡언월도 -->
                    <line x1="50" y1="180" x2="20" y2="220" stroke="#8b4513" stroke-width="6" stroke-linecap="round"/>
                    <path d="M 20 220 L 15 240 L 25 240 Z" fill="#ffd700"/>
                    <circle cx="20" cy="220" r="8" fill="#ffd700"/>
                    
                    <!-- 하체 갑옷 -->
                    <path d="M 70 240 Q 70 250, 80 255 L 220 255 Q 230 250, 230 240 L 230 350 Q 230 360, 220 365 L 80 365 Q 70 360, 70 350 Z" fill="url(#guanYuGrad)"/>
                    <rect x="100" y="250" width="100" height="20" fill="#ff0000" rx="5"/>
                    
                    <!-- 발 -->
                    <ellipse cx="120" cy="370" rx="25" ry="15" fill="#8b4513"/>
                    <ellipse cx="180" cy="370" rx="25" ry="15" fill="#8b4513"/>
                    
                    <!-- 오라 효과 -->
                    <circle cx="150" cy="200" r="180" fill="none" stroke="rgba(34, 139, 34, 0.3)" stroke-width="2" filter="url(#glow)"/>
                </svg>
            `;
        }
        
        function getZhugeLiangIllustration() {
            return `
                <svg viewBox="0 0 300 400" style="width: 100%; height: auto;">
                    <defs>
                        <linearGradient id="zhugeGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#87ceeb;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#4682b4;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    
                    <!-- 도사 모자 -->
                    <path d="M 120 50 L 180 50 L 175 30 L 125 30 Z" fill="#4169e1"/>
                    <path d="M 125 30 L 175 30 L 170 20 L 130 20 Z" fill="#000080"/>
                    <circle cx="150" cy="25" r="5" fill="#ffd700"/>
                    
                    <!-- 머리 -->
                    <circle cx="150" cy="100" r="55" fill="#d2b48c"/>
                    <circle cx="150" cy="105" r="48" fill="#fdbcb4"/>
                    
                    <!-- 긴 수염 -->
                    <path d="M 130 120 Q 120 180, 110 240" stroke="#d2b48c" stroke-width="6" fill="none" stroke-linecap="round"/>
                    <path d="M 170 120 Q 180 180, 190 240" stroke="#d2b48c" stroke-width="6" fill="none" stroke-linecap="round"/>
                    
                    <!-- 눈 -->
                    <circle cx="135" cy="100" r="4" fill="#000"/>
                    <circle cx="165" cy="100" r="4" fill="#000"/>
                    
                    <!-- 입 -->
                    <path d="M 140 115 Q 150 120, 160 115" stroke="#8b4513" stroke-width="2" fill="none"/>
                    
                    <!-- 도사 복장 -->
                    <path d="M 90 150 Q 90 140, 110 135 L 190 135 Q 210 140, 210 150 L 210 250 Q 210 260, 190 265 L 110 265 Q 90 260, 90 250 Z" fill="url(#zhugeGrad)"/>
                    <rect x="110" y="145" width="80" height="20" fill="#ffffff" rx="5"/>
                    
                    <!-- 팔 -->
                    <rect x="70" y="155" width="30" height="90" fill="url(#zhugeGrad)" rx="8"/>
                    <rect x="200" y="155" width="30" height="90" fill="url(#zhugeGrad)" rx="8"/>
                    
                    <!-- 부채 -->
                    <path d="M 230 160 L 280 140 L 280 200 L 230 180 Z" fill="#ffd700"/>
                    <line x1="230" y1="170" x2="280" y2="150" stroke="#8b4513" stroke-width="2"/>
                    <line x1="230" y1="175" x2="280" y2="155" stroke="#8b4513" stroke-width="2"/>
                    <line x1="230" y1="180" x2="280" y2="160" stroke="#8b4513" stroke-width="2"/>
                    
                    <!-- 하체 -->
                    <path d="M 80 270 Q 80 280, 90 285 L 210 285 Q 220 280, 220 270 L 220 360 Q 220 370, 210 375 L 90 375 Q 80 370, 80 360 Z" fill="url(#zhugeGrad)"/>
                    
                    <!-- 발 -->
                    <ellipse cx="120" cy="380" rx="20" ry="12" fill="#8b4513"/>
                    <ellipse cx="180" cy="380" rx="20" ry="12" fill="#8b4513"/>
                    
                    <!-- 오라 효과 -->
                    <circle cx="150" cy="200" r="160" fill="none" stroke="rgba(135, 206, 235, 0.3)" stroke-width="2"/>
                </svg>
            `;
        }
        
        function getZhangFeiIllustration() {
            return `
                <svg viewBox="0 0 300 400" style="width: 100%; height: auto;">
                    <defs>
                        <linearGradient id="zhangFeiGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#006400;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#003300;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    
                    <!-- 머리 -->
                    <circle cx="150" cy="100" r="60" fill="#8b4513"/>
                    <circle cx="150" cy="105" r="50" fill="#8b4513"/>
                    
                    <!-- 얼굴 (검은 피부) -->
                    <circle cx="150" cy="105" r="48" fill="#654321"/>
                    
                    <!-- 눈썹 (두꺼운) -->
                    <rect x="115" y="85" width="30" height="10" fill="#000" rx="5"/>
                    <rect x="155" y="85" width="30" height="10" fill="#000" rx="5"/>
                    
                    <!-- 눈 (크고 둥근) -->
                    <circle cx="135" cy="100" r="7" fill="#fff"/>
                    <circle cx="165" cy="100" r="7" fill="#fff"/>
                    <circle cx="135" cy="100" r="4" fill="#000"/>
                    <circle cx="165" cy="100" r="4" fill="#000"/>
                    
                    <!-- 코 -->
                    <ellipse cx="150" cy="110" rx="8" ry="12" fill="#8b4513"/>
                    
                    <!-- 입 (크게 벌림) -->
                    <ellipse cx="150" cy="125" rx="15" ry="10" fill="#000"/>
                    <ellipse cx="150" cy="125" rx="12" ry="7" fill="#8b0000"/>
                    
                    <!-- 수염 (검은색, 거친) -->
                    <path d="M 100 130 Q 80 180, 70 240" stroke="#000" stroke-width="8" fill="none" stroke-linecap="round"/>
                    <path d="M 200 130 Q 220 180, 230 240" stroke="#000" stroke-width="8" fill="none" stroke-linecap="round"/>
                    <rect x="120" y="130" width="60" height="30" fill="#000" rx="15"/>
                    
                    <!-- 투구 -->
                    <path d="M 100 60 L 200 60 L 195 40 L 105 40 Z" fill="#006400"/>
                    <path d="M 105 40 L 195 40 L 190 30 L 110 30 Z" fill="#ffd700"/>
                    <circle cx="150" cy="35" r="6" fill="#ff0000"/>
                    
                    <!-- 갑옷 -->
                    <path d="M 75 150 Q 75 140, 95 135 L 205 135 Q 225 140, 225 150 L 225 230 Q 225 240, 205 245 L 95 245 Q 75 240, 75 230 Z" fill="url(#zhangFeiGrad)"/>
                    <rect x="95" y="145" width="110" height="30" fill="#ffd700" rx="5"/>
                    
                    <!-- 팔 -->
                    <rect x="55" y="155" width="35" height="90" fill="url(#zhangFeiGrad)" rx="8"/>
                    <rect x="210" y="155" width="35" height="90" fill="url(#zhangFeiGrad)" rx="8"/>
                    
                    <!-- 창 -->
                    <line x1="40" y1="200" x2="10" y2="250" stroke="#8b4513" stroke-width="8" stroke-linecap="round"/>
                    <path d="M 10 250 L 5 270 L 15 270 Z" fill="#ffd700"/>
                    
                    <!-- 하체 -->
                    <path d="M 70 250 Q 70 260, 80 265 L 220 265 Q 230 260, 230 250 L 230 360 Q 230 370, 220 375 L 80 375 Q 70 370, 70 360 Z" fill="url(#zhangFeiGrad)"/>
                    
                    <!-- 발 -->
                    <ellipse cx="120" cy="380" rx="28" ry="18" fill="#8b4513"/>
                    <ellipse cx="180" cy="380" rx="28" ry="18" fill="#8b4513"/>
                    
                    <!-- 오라 효과 -->
                    <circle cx="150" cy="200" r="170" fill="none" stroke="rgba(0, 100, 0, 0.3)" stroke-width="2"/>
                </svg>
            `;
        }
        
        function getZhaoYunIllustration() {
            return `
                <svg viewBox="0 0 300 400" style="width: 100%; height: auto;">
                    <defs>
                        <linearGradient id="zhaoYunGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#4169e1;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#1e3a8a;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    
                    <!-- 머리 -->
                    <circle cx="150" cy="100" r="55" fill="#d2b48c"/>
                    <circle cx="150" cy="105" r="48" fill="#fdbcb4"/>
                    
                    <!-- 투구 -->
                    <path d="M 110 70 L 190 70 L 185 50 L 115 50 Z" fill="#4169e1"/>
                    <path d="M 115 50 L 185 50 L 180 40 L 120 40 Z" fill="#ffffff"/>
                    <circle cx="150" cy="45" r="5" fill="#ffd700"/>
                    <path d="M 150 50 L 150 70" stroke="#ffd700" stroke-width="3"/>
                    
                    <!-- 눈 -->
                    <circle cx="135" cy="100" r="5" fill="#000"/>
                    <circle cx="165" cy="100" r="5" fill="#000"/>
                    <circle cx="137" cy="98" r="2" fill="#fff"/>
                    <circle cx="167" cy="98" r="2" fill="#fff"/>
                    
                    <!-- 입 -->
                    <path d="M 140 115 Q 150 120, 160 115" stroke="#8b4513" stroke-width="2" fill="none"/>
                    
                    <!-- 갑옷 -->
                    <path d="M 85 150 Q 85 140, 105 135 L 195 135 Q 215 140, 215 150 L 215 240 Q 215 250, 195 255 L 105 255 Q 85 250, 85 240 Z" fill="url(#zhaoYunGrad)"/>
                    <rect x="105" y="145" width="90" height="25" fill="#ffffff" rx="5"/>
                    <rect x="115" y="150" width="70" height="15" fill="#4169e1" rx="3"/>
                    
                    <!-- 어깨 갑옷 -->
                    <ellipse cx="80" cy="165" rx="25" ry="18" fill="#4169e1"/>
                    <ellipse cx="220" cy="165" rx="25" ry="18" fill="#4169e1"/>
                    
                    <!-- 팔 -->
                    <rect x="60" y="160" width="32" height="85" fill="url(#zhaoYunGrad)" rx="8"/>
                    <rect x="208" y="160" width="32" height="85" fill="url(#zhaoYunGrad)" rx="8"/>
                    
                    <!-- 용창 -->
                    <line x1="45" y1="200" x2="15" y2="260" stroke="#8b4513" stroke-width="6" stroke-linecap="round"/>
                    <path d="M 15 260 L 10 280 L 20 280 Z" fill="#ffd700"/>
                    <circle cx="15" cy="260" r="6" fill="#ffd700"/>
                    
                    <!-- 하체 -->
                    <path d="M 75 250 Q 75 260, 85 265 L 215 265 Q 225 260, 225 250 L 225 360 Q 225 370, 215 375 L 85 375 Q 75 370, 75 360 Z" fill="url(#zhaoYunGrad)"/>
                    <rect x="105" y="260" width="90" height="20" fill="#ffffff" rx="5"/>
                    
                    <!-- 발 -->
                    <ellipse cx="120" cy="380" rx="22" ry="14" fill="#8b4513"/>
                    <ellipse cx="180" cy="380" rx="22" ry="14" fill="#8b4513"/>
                    
                    <!-- 오라 효과 -->
                    <circle cx="150" cy="200" r="165" fill="none" stroke="rgba(65, 105, 225, 0.3)" stroke-width="2"/>
                </svg>
            `;
        }
        
        function getLiuBeiIllustration() {
            return `
                <svg viewBox="0 0 300 400" style="width: 100%; height: auto;">
                    <defs>
                        <linearGradient id="liuBeiGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#ffd700;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#daa520;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    
                    <!-- 머리 -->
                    <circle cx="150" cy="100" r="55" fill="#d2b48c"/>
                    <circle cx="150" cy="105" r="48" fill="#fdbcb4"/>
                    
                    <!-- 황제 관 -->
                    <path d="M 100 60 L 200 60 L 195 40 L 105 40 Z" fill="#ffd700"/>
                    <path d="M 105 40 L 195 40 L 190 30 L 110 30 Z" fill="#ff8c00"/>
                    <circle cx="150" cy="35" r="8" fill="#ff0000"/>
                    <path d="M 120 50 L 180 50" stroke="#ff0000" stroke-width="2"/>
                    
                    <!-- 눈 -->
                    <circle cx="135" cy="100" r="4" fill="#000"/>
                    <circle cx="165" cy="100" r="4" fill="#000"/>
                    
                    <!-- 입 -->
                    <path d="M 140 115 Q 150 120, 160 115" stroke="#8b4513" stroke-width="2" fill="none"/>
                    
                    <!-- 수염 -->
                    <path d="M 120 120 Q 110 180, 100 240" stroke="#d2b48c" stroke-width="5" fill="none" stroke-linecap="round"/>
                    <path d="M 180 120 Q 190 180, 200 240" stroke="#d2b48c" stroke-width="5" fill="none" stroke-linecap="round"/>
                    
                    <!-- 황제 복장 -->
                    <path d="M 90 150 Q 90 140, 110 135 L 190 135 Q 210 140, 210 150 L 210 250 Q 210 260, 190 265 L 110 265 Q 90 260, 90 250 Z" fill="url(#liuBeiGrad)"/>
                    <rect x="110" y="145" width="80" height="30" fill="#ff0000" rx="5"/>
                    <rect x="120" y="150" width="60" height="20" fill="#ffd700" rx="3"/>
                    
                    <!-- 용 문양 -->
                    <path d="M 130 160 Q 140 155, 150 160 Q 160 155, 170 160" stroke="#ff0000" stroke-width="2" fill="none"/>
                    
                    <!-- 팔 -->
                    <rect x="70" y="160" width="30" height="85" fill="url(#liuBeiGrad)" rx="8"/>
                    <rect x="200" y="160" width="30" height="85" fill="url(#liuBeiGrad)" rx="8"/>
                    
                    <!-- 하체 -->
                    <path d="M 80 260 Q 80 270, 90 275 L 210 275 Q 220 270, 220 260 L 220 360 Q 220 370, 210 375 L 90 375 Q 80 370, 80 360 Z" fill="url(#liuBeiGrad)"/>
                    <rect x="110" y="270" width="80" height="25" fill="#ff0000" rx="5"/>
                    
                    <!-- 발 -->
                    <ellipse cx="120" cy="380" rx="20" ry="12" fill="#8b4513"/>
                    <ellipse cx="180" cy="380" rx="20" ry="12" fill="#8b4513"/>
                    
                    <!-- 오라 효과 -->
                    <circle cx="150" cy="200" r="160" fill="none" stroke="rgba(255, 215, 0, 0.3)" stroke-width="2"/>
                </svg>
            `;
        }
        
        function getLuBuIllustration() {
            return `
                <svg viewBox="0 0 300 400" style="width: 100%; height: auto;">
                    <defs>
                        <linearGradient id="luBuGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#9370db;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:#4b0082;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    
                    <!-- 머리 -->
                    <circle cx="150" cy="100" r="60" fill="#8b4513"/>
                    <circle cx="150" cy="105" r="50" fill="#654321"/>
                    
                    <!-- 투구 (화려한) -->
                    <path d="M 100 55 L 200 55 L 195 35 L 105 35 Z" fill="#9370db"/>
                    <path d="M 105 35 L 195 35 L 190 25 L 110 25 Z" fill="#ffd700"/>
                    <circle cx="150" cy="30" r="6" fill="#ff0000"/>
                    <path d="M 120 50 L 180 50" stroke="#ffd700" stroke-width="2"/>
                    
                    <!-- 눈썹 -->
                    <rect x="120" y="85" width="30" height="8" fill="#000" rx="4"/>
                    <rect x="150" y="85" width="30" height="8" fill="#000" rx="4"/>
                    
                    <!-- 눈 (사나운) -->
                    <circle cx="135" cy="100" r="6" fill="#fff"/>
                    <circle cx="165" cy="100" r="6" fill="#fff"/>
                    <circle cx="135" cy="100" r="4" fill="#000"/>
                    <circle cx="165" cy="100" r="4" fill="#000"/>
                    
                    <!-- 입 -->
                    <path d="M 140 115 Q 150 120, 160 115" stroke="#8b4513" stroke-width="3" fill="none"/>
                    
                    <!-- 수염 -->
                    <path d="M 110 120 Q 100 180, 90 240" stroke="#8b4513" stroke-width="6" fill="none" stroke-linecap="round"/>
                    <path d="M 190 120 Q 200 180, 210 240" stroke="#8b4513" stroke-width="6" fill="none" stroke-linecap="round"/>
                    
                    <!-- 갑옷 -->
                    <path d="M 75 150 Q 75 140, 95 135 L 205 135 Q 225 140, 225 150 L 225 250 Q 225 260, 205 265 L 95 265 Q 75 260, 75 250 Z" fill="url(#luBuGrad)"/>
                    <rect x="95" y="145" width="110" height="30" fill="#ffd700" rx="5"/>
                    <rect x="105" y="150" width="90" height="20" fill="#9370db" rx="3"/>
                    
                    <!-- 어깨 갑옷 (큰) -->
                    <ellipse cx="70" cy="170" rx="30" ry="20" fill="#9370db"/>
                    <ellipse cx="230" cy="170" rx="30" ry="20" fill="#9370db"/>
                    
                    <!-- 팔 -->
                    <rect x="50" y="165" width="38" height="95" fill="url(#luBuGrad)" rx="8"/>
                    <rect x="212" y="165" width="38" height="95" fill="url(#luBuGrad)" rx="8"/>
                    
                    <!-- 방천화극 -->
                    <line x1="35" y1="210" x2="5" y2="280" stroke="#8b4513" stroke-width="10" stroke-linecap="round"/>
                    <path d="M 5 280 L 0 300 L 10 300 Z" fill="#ffd700"/>
                    <circle cx="5" cy="280" r="8" fill="#ffd700"/>
                    <path d="M 5 270 L 5 290" stroke="#ff0000" stroke-width="2"/>
                    
                    <!-- 하체 -->
                    <path d="M 70 260 Q 70 270, 80 275 L 220 275 Q 230 270, 230 260 L 230 360 Q 230 370, 220 375 L 80 375 Q 70 370, 70 360 Z" fill="url(#luBuGrad)"/>
                    <rect x="95" y="270" width="110" height="25" fill="#ffd700" rx="5"/>
                    
                    <!-- 발 -->
                    <ellipse cx="120" cy="380" rx="28" ry="18" fill="#8b4513"/>
                    <ellipse cx="180" cy="380" rx="28" ry="18" fill="#8b4513"/>
                    
                    <!-- 오라 효과 (강력한) -->
                    <circle cx="150" cy="200" r="180" fill="none" stroke="rgba(147, 112, 219, 0.4)" stroke-width="3"/>
                    <circle cx="150" cy="200" r="160" fill="none" stroke="rgba(255, 0, 0, 0.2)" stroke-width="2"/>
                </svg>
            `;
        }
        
        // 위(魏) 일러스트 함수들
        function getCaoCaoIllustration() {
            return getGuanYuIllustration().replace(/#228b22/g, '#8b0000').replace(/관우/g, '조조');
        }
        
        function getXiahouDunIllustration() {
            return getGuanYuIllustration().replace(/#228b22/g, '#dc143c').replace(/관우/g, '하후돈');
        }
        
        function getZhangLiaoIllustration() {
            return getZhaoYunIllustration().replace(/#4169e1/g, '#ff6347').replace(/조운/g, '장료');
        }
        
        function getXuZhuIllustration() {
            return getZhangFeiIllustration().replace(/#006400/g, '#ff4500').replace(/장비/g, '허저');
        }
        
        // 촉(蜀) 일러스트 함수들
        function getHuangZhongIllustration() {
            return getZhugeLiangIllustration().replace(/#87ceeb/g, '#ffa500').replace(/제갈량/g, '황충');
        }
        
        function getMaChaoIllustration() {
            return getZhaoYunIllustration().replace(/#4169e1/g, '#ff8c00').replace(/조운/g, '마초');
        }
        
        function getWeiYanIllustration() {
            return getGuanYuIllustration().replace(/#228b22/g, '#daa520').replace(/관우/g, '위연');
        }
        
        // 오(吳) 일러스트 함수들
        function getSunQuanIllustration() {
            return getLiuBeiIllustration().replace(/#ffd700/g, '#4169e1').replace(/유비/g, '손권');
        }
        
        function getZhuYuIllustration() {
            return getZhugeLiangIllustration().replace(/#87ceeb/g, '#1e90ff').replace(/제갈량/g, '주유');
        }
        
        function getGanNingIllustration() {
            return getZhaoYunIllustration().replace(/#4169e1/g, '#00bfff').replace(/조운/g, '감녕');
        }
        
        function getTaiShiCiIllustration() {
            return getZhugeLiangIllustration().replace(/제갈량/g, '태사자');
        }
        
        function updateSkillsSection(heroType) {
            const skillsDiv = document.getElementById('heroSkillsSection');
            skillsDiv.innerHTML = '';
            
            const skillData = [
                { icon: '⚔️', name: '청룡언월도', level: 4 },
                { icon: '🌟', name: '팔괘진', level: 4 },
                { icon: '💥', name: '포효', level: 3 },
                { icon: '⚡', name: '용창', level: 3 }
            ];
            
            const heroSkills = [
                [{ icon: '⚔️', name: '청룡언월도', level: 4 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '🛡️', name: '방어', level: 2 }, { icon: '🔥', name: '분노', level: 3 }],
                [{ icon: '🌟', name: '팔괘진', level: 4 }, { icon: '❄️', name: '얼음', level: 3 }, { icon: '⚡', name: '번개', level: 3 }, { icon: '💫', name: '예언', level: 2 }],
                [{ icon: '💥', name: '포효', level: 4 }, { icon: '⚔️', name: '참격', level: 3 }, { icon: '🛡️', name: '철벽', level: 3 }, { icon: '🔥', name: '분노', level: 2 }],
                [{ icon: '⚡', name: '용창', level: 4 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚔️', name: '연속공격', level: 3 }, { icon: '🛡️', name: '회피', level: 2 }],
                [{ icon: '👑', name: '인의', level: 4 }, { icon: '🤝', name: '협력', level: 3 }, { icon: '💎', name: '지혜', level: 3 }, { icon: '🌟', name: '리더십', level: 2 }],
                [{ icon: '🔥', name: '천하무쌍', level: 4 }, { icon: '⚔️', name: '참격', level: 3 }, { icon: '💥', name: '폭발', level: 3 }, { icon: '👹', name: '광기', level: 2 }],
                // 위(魏)
                [{ icon: '👑', name: '천하통일', level: 4 }, { icon: '⚔️', name: '참격', level: 3 }, { icon: '🛡️', name: '방어', level: 2 }, { icon: '💎', name: '지략', level: 3 }],
                [{ icon: '⚔️', name: '맹장', level: 4 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '🛡️', name: '방어', level: 2 }, { icon: '🔥', name: '분노', level: 3 }],
                [{ icon: '⚡', name: '돌격', level: 4 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚔️', name: '연속공격', level: 3 }, { icon: '🛡️', name: '회피', level: 2 }],
                [{ icon: '🛡️', name: '철벽', level: 4 }, { icon: '💪', name: '방어', level: 3 }, { icon: '🛡️', name: '수비', level: 3 }, { icon: '🔥', name: '분노', level: 2 }],
                [{ icon: '⚔️', name: '신속', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚡', name: '번개', level: 2 }, { icon: '🛡️', name: '회피', level: 2 }],
                [{ icon: '🛡️', name: '방어', level: 3 }, { icon: '💪', name: '수비', level: 3 }, { icon: '⚔️', name: '참격', level: 2 }, { icon: '🔥', name: '분노', level: 2 }],
                [{ icon: '⚔️', name: '돌파', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚡', name: '번개', level: 2 }, { icon: '🛡️', name: '회피', level: 2 }],
                [{ icon: '🛡️', name: '수비', level: 3 }, { icon: '💪', name: '방어', level: 3 }, { icon: '⚔️', name: '참격', level: 2 }, { icon: '🔥', name: '분노', level: 2 }],
                [{ icon: '⚔️', name: '기동', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚡', name: '번개', level: 2 }, { icon: '🛡️', name: '회피', level: 2 }],
                [{ icon: '⚔️', name: '돌진', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚡', name: '번개', level: 2 }, { icon: '🛡️', name: '회피', level: 2 }],
                [{ icon: '⚔️', name: '맹공', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚡', name: '번개', level: 2 }, { icon: '🔥', name: '분노', level: 2 }],
                [{ icon: '⚔️', name: '돌격', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚡', name: '번개', level: 2 }, { icon: '🔥', name: '분노', level: 2 }],
                // 촉(蜀)
                [{ icon: '🏹', name: '백보양양', level: 4 }, { icon: '⚡', name: '번개', level: 3 }, { icon: '💨', name: '돌격', level: 2 }, { icon: '🔥', name: '분노', level: 3 }],
                [{ icon: '🐴', name: '서량기마', level: 4 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚔️', name: '연속공격', level: 3 }, { icon: '🛡️', name: '회피', level: 2 }],
                [{ icon: '⚔️', name: '돌진', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚡', name: '번개', level: 2 }, { icon: '🛡️', name: '회피', level: 2 }],
                [{ icon: '🌟', name: '지략', level: 4 }, { icon: '❄️', name: '얼음', level: 3 }, { icon: '⚡', name: '번개', level: 3 }, { icon: '💫', name: '예언', level: 2 }],
                [{ icon: '⚔️', name: '유전', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '🛡️', name: '방어', level: 2 }, { icon: '🔥', name: '분노', level: 2 }],
                [{ icon: '⚔️', name: '유전', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '🛡️', name: '방어', level: 2 }, { icon: '🔥', name: '분노', level: 2 }],
                [{ icon: '💥', name: '유전', level: 3 }, { icon: '⚔️', name: '참격', level: 3 }, { icon: '🛡️', name: '철벽', level: 2 }, { icon: '🔥', name: '분노', level: 2 }],
                [{ icon: '🐴', name: '유전', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚔️', name: '연속공격', level: 2 }, { icon: '🛡️', name: '회피', level: 2 }],
                // 오(吳)
                [{ icon: '👑', name: '동맹', level: 4 }, { icon: '🤝', name: '협력', level: 3 }, { icon: '💎', name: '지혜', level: 3 }, { icon: '🌟', name: '리더십', level: 2 }],
                [{ icon: '🔥', name: '화공', level: 4 }, { icon: '⚡', name: '번개', level: 3 }, { icon: '❄️', name: '얼음', level: 3 }, { icon: '💫', name: '예언', level: 2 }],
                [{ icon: '⚔️', name: '해적', level: 4 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚡', name: '번개', level: 3 }, { icon: '🛡️', name: '회피', level: 2 }],
                [{ icon: '🏹', name: '궁술', level: 4 }, { icon: '⚡', name: '번개', level: 3 }, { icon: '💨', name: '돌격', level: 2 }, { icon: '🔥', name: '분노', level: 3 }],
                [{ icon: '⚔️', name: '기습', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚡', name: '번개', level: 2 }, { icon: '🛡️', name: '회피', level: 2 }],
                [{ icon: '🌟', name: '지략', level: 4 }, { icon: '❄️', name: '얼음', level: 3 }, { icon: '⚡', name: '번개', level: 3 }, { icon: '💫', name: '예언', level: 2 }],
                [{ icon: '🔥', name: '패기', level: 4 }, { icon: '⚔️', name: '참격', level: 3 }, { icon: '💥', name: '폭발', level: 3 }, { icon: '👹', name: '광기', level: 2 }],
                [{ icon: '🛡️', name: '수호', level: 3 }, { icon: '💪', name: '방어', level: 3 }, { icon: '⚔️', name: '참격', level: 2 }, { icon: '🔥', name: '분노', level: 2 }],
                [{ icon: '⚔️', name: '돌격', level: 3 }, { icon: '💨', name: '돌격', level: 3 }, { icon: '⚡', name: '번개', level: 2 }, { icon: '🛡️', name: '회피', level: 2 }],
                [{ icon: '🛡️', name: '방어', level: 3 }, { icon: '💪', name: '수비', level: 3 }, { icon: '⚔️', name: '참격', level: 2 }, { icon: '🔥', name: '분노', level: 2 }]
            ];
            
            const skills = heroSkills[heroType] || heroSkills[0];
            const stars = heroStars[heroType] || 1;
            
            skills.forEach((skill, index) => {
                const skillDiv = document.createElement('div');
                skillDiv.className = 'skill-icon';
                const skillLevel = Math.min(skill.level + Math.floor(stars / 2), 5);
                skillDiv.innerHTML = `
                    <div style="font-size: 24px;">${skill.icon}</div>
                    <div class="skill-level">Lv.${skillLevel}</div>
                `;
                skillDiv.title = skill.name;
                skillsDiv.appendChild(skillDiv);
            });
        }
        
        function unequipAllEquipment(heroType) {
            if (!heroEquipment[heroType]) return;
            
            for (const slot in heroEquipment[heroType]) {
                const equipId = heroEquipment[heroType][slot];
                if (equipId) {
                    equipmentInventory[equipId] = (equipmentInventory[equipId] || 0) + 1;
                }
            }
            
            heroEquipment[heroType] = {};
            showHeroDetail(heroType);
            updateHeroCollection();
            alert('모든 장비를 해제했습니다!');
        }
        
        function equipBestEquipment(heroType) {
            const availableEquipment = {};
            
            // 보유한 장비를 부위별로 분류
            for (const [equipId, count] of Object.entries(equipmentInventory)) {
                if (count > 0 && equipmentDatabase[equipId]) {
                    const equip = equipmentDatabase[equipId];
                    if (!availableEquipment[equip.type]) {
                        availableEquipment[equip.type] = [];
                    }
                    availableEquipment[equip.type].push({ id: equipId, ...equip });
                }
            }
            
            // 각 부위별로 가장 좋은 장비 착용
            let equippedCount = 0;
            EquipmentSlots.forEach(slot => {
                if (availableEquipment[slot.type] && availableEquipment[slot.type].length > 0) {
                    // 능력치 합계로 정렬
                    const best = availableEquipment[slot.type].sort((a, b) => {
                        const aValue = (a.attack || 0) + (a.health || 0) + (a.attackSpeed || 0) * 100;
                        const bValue = (b.attack || 0) + (b.health || 0) + (b.attackSpeed || 0) * 100;
                        return bValue - aValue;
                    })[0];
                    
                    equipItem(heroType, slot.type, best.id);
                    equippedCount++;
                }
            });
            
            if (equippedCount > 0) {
                alert(`${equippedCount}개의 장비를 자동으로 장착했습니다!`);
            } else {
                alert('장착할 수 있는 장비가 없습니다!');
            }
        }
        
        function showFullInventory() {
            const modal = document.getElementById('equipmentInventoryModal');
            const title = document.getElementById('inventoryTitle');
            const list = document.getElementById('equipmentInventoryList');
            
            title.textContent = '장비 인벤토리';
            list.innerHTML = '';
            
            const equipmentByType = {
                [EquipmentType.WEAPON]: [],
                [EquipmentType.ARMOR]: [],
                [EquipmentType.HELMET]: [],
                [EquipmentType.ACCESSORY]: []
            };
            
            for (const [equipId, count] of Object.entries(equipmentInventory)) {
                if (count > 0 && equipmentDatabase[equipId]) {
                    const equip = equipmentDatabase[equipId];
                    equipmentByType[equip.type].push({ id: equipId, ...equip, count });
                }
            }
            
            const typeNames = {
                [EquipmentType.WEAPON]: '무기',
                [EquipmentType.ARMOR]: '갑옷',
                [EquipmentType.HELMET]: '투구',
                [EquipmentType.ACCESSORY]: '장신구'
            };
            
            for (const [type, items] of Object.entries(equipmentByType)) {
                if (items.length > 0) {
                    const typeHeader = document.createElement('div');
                    typeHeader.style.cssText = 'font-size: 20px; font-weight: bold; margin: 20px 0 10px 0; color: #ffd700;';
                    typeHeader.textContent = typeNames[type];
                    list.appendChild(typeHeader);
                    
                    items.forEach(equip => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'inventory-item';
                        
                        const statsText = [];
                        if (equip.attack) statsText.push(`공격력 +${equip.attack}`);
                        if (equip.attackSpeed) statsText.push(`공속 +${(equip.attackSpeed * 100).toFixed(0)}%`);
                        if (equip.range) statsText.push(`범위 +${(equip.range * 100).toFixed(0)}%`);
                        if (equip.health) statsText.push(`체력 +${equip.health}`);
                        if (equip.defense) statsText.push(`방어력 +${(equip.defense * 100).toFixed(0)}%`);
                        if (equip.critChance) statsText.push(`치명타 +${(equip.critChance * 100).toFixed(0)}%`);
                        
                        itemDiv.innerHTML = `
                            <div class="inventory-item-name">${equip.name} (보유: ${equip.count}개)</div>
                            <div class="inventory-item-stats">${statsText.join(', ')}</div>
                        `;
                        
                        list.appendChild(itemDiv);
                    });
                }
            }
            
            if (list.innerHTML === '') {
                list.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">보유한 장비가 없습니다.</div>';
            }
            
            modal.classList.add('show');
        }
        
        function showEquipmentInventory(heroType, slotType) {
            const modal = document.getElementById('equipmentInventoryModal');
            const title = document.getElementById('inventoryTitle');
            const list = document.getElementById('equipmentInventoryList');
            
            title.textContent = `${HeroNames[heroType]} - ${EquipmentSlots.find(s => s.type === slotType).name} 장착`;
            list.innerHTML = '';
            
            // 보유한 장비 필터링
            const availableEquipment = [];
            for (const [equipId, count] of Object.entries(equipmentInventory)) {
                if (count > 0 && equipmentDatabase[equipId] && equipmentDatabase[equipId].type === slotType) {
                    availableEquipment.push({ id: equipId, ...equipmentDatabase[equipId], count });
                }
            }
            
            if (availableEquipment.length === 0) {
                list.innerHTML = '<div style="text-align: center; padding: 20px; color: #888;">보유한 장비가 없습니다.</div>';
            } else {
                availableEquipment.forEach(equip => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'inventory-item';
                    
                    const statsText = [];
                    if (equip.attack) statsText.push(`공격력 +${equip.attack}`);
                    if (equip.attackSpeed) statsText.push(`공속 +${(equip.attackSpeed * 100).toFixed(0)}%`);
                    if (equip.range) statsText.push(`범위 +${(equip.range * 100).toFixed(0)}%`);
                    if (equip.health) statsText.push(`체력 +${equip.health}`);
                    if (equip.defense) statsText.push(`방어력 +${(equip.defense * 100).toFixed(0)}%`);
                    if (equip.critChance) statsText.push(`치명타 +${(equip.critChance * 100).toFixed(0)}%`);
                    
                    itemDiv.innerHTML = `
                        <div class="inventory-item-name">${equip.name} (보유: ${equip.count}개)</div>
                        <div class="inventory-item-stats">${statsText.join(', ')}</div>
                    `;
                    
                    itemDiv.addEventListener('click', () => {
                        equipItem(heroType, slotType, equip.id);
                    });
                    
                    list.appendChild(itemDiv);
                });
            }
            
            // 현재 착용한 장비 해제 옵션
            const currentEquip = heroEquipment[heroType] && heroEquipment[heroType][slotType];
            if (currentEquip) {
                const removeDiv = document.createElement('div');
                removeDiv.className = 'inventory-item';
                removeDiv.style.border = '2px solid #dc143c';
                removeDiv.innerHTML = `
                    <div class="inventory-item-name" style="color: #dc143c;">장비 해제</div>
                    <div class="inventory-item-stats">현재 착용한 장비를 해제합니다</div>
                `;
                removeDiv.addEventListener('click', () => {
                    unequipItem(heroType, slotType);
                });
                list.insertBefore(removeDiv, list.firstChild);
            }
            
            modal.classList.add('show');
        }
        
        function closeEquipmentInventory() {
            document.getElementById('equipmentInventoryModal').classList.remove('show');
        }
        
        function levelUpHero(heroType) {
            const stars = heroStars[heroType] || 1;
            const currentLevel = stars * 100 + 73;
            const maxLevel = stars * 100 + 160;
            
            if (currentLevel >= maxLevel) {
                alert('이미 최대 레벨입니다! 별 등급을 올려야 레벨을 더 올릴 수 있습니다.');
                return;
            }
            
            const cost = Math.floor(currentLevel * 10);
            if (gold < cost) {
                alert(`레벨업에 필요한 금화가 부족합니다! (필요: ${cost.toLocaleString()} 금화)`);
                return;
            }
            
            gold -= cost;
            // 레벨업은 별 등급 시스템과 연동되어 있으므로 여기서는 별 등급을 올리는 것으로 대체
            // 실제로는 별도 레벨 시스템이 필요할 수 있음
            alert(`${HeroNames[heroType]}의 레벨이 올라갔습니다!`);
            showHeroDetail(heroType);
            updateUI();
        }
        
        function moveToCommandPost() {
            alert('통솔부 기능은 준비 중입니다!');
        }
        
        function equipItem(heroType, slotType, equipId) {
            if (!heroEquipment[heroType]) {
                heroEquipment[heroType] = {};
            }
            
            // 기존 장비가 있으면 인벤토리로 반환
            const oldEquip = heroEquipment[heroType][slotType];
            if (oldEquip) {
                equipmentInventory[oldEquip] = (equipmentInventory[oldEquip] || 0) + 1;
            }
            
            // 새 장비 착용
            heroEquipment[heroType][slotType] = equipId;
            equipmentInventory[equipId] = (equipmentInventory[equipId] || 0) - 1;
            
            if (equipmentInventory[equipId] <= 0) {
                delete equipmentInventory[equipId];
            }
            
            closeEquipmentInventory();
            showHeroDetail(heroType);
            updateHeroCollection();
        }
        
        function unequipItem(heroType, slotType) {
            if (!heroEquipment[heroType] || !heroEquipment[heroType][slotType]) return;
            
            const equipId = heroEquipment[heroType][slotType];
            equipmentInventory[equipId] = (equipmentInventory[equipId] || 0) + 1;
            delete heroEquipment[heroType][slotType];
            
            closeEquipmentInventory();
            showHeroDetail(heroType);
            updateHeroCollection();
        }

        function getHighestGrade(heroType) {
            if (!heroCollection[heroType]) return null;
            const grades = [HeroGrade.SSR, HeroGrade.SR, HeroGrade.R, HeroGrade.N];
            for (const grade of grades) {
                if (heroCollection[heroType][grade] && heroCollection[heroType][grade] > 0) {
                    return grade;
                }
            }
            return null;
        }

        function updateHeroSelection() {
            const selectionDiv = document.getElementById('heroSelection');
            selectionDiv.innerHTML = '';
            
            for (let i = 0; i < HeroNames.length; i++) {
                const totalCards = getTotalHeroCards(i);
                const stars = heroStars[i] || 1;
                
                if (totalCards === 0 && stars === 1) continue;
                
                const btn = document.createElement('button');
                btn.className = 'hero-btn';
                btn.textContent = `${HeroNames[i]} (${i + 1}) ${'★'.repeat(stars)}`;
                btn.dataset.hero = i;
                btn.addEventListener('click', () => {
                    placingHeroType = i;
                    document.querySelectorAll('.hero-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                });
                selectionDiv.appendChild(btn);
            }
        }

        // 영웅 클래스 (별 등급 반영)
        class Hero {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.stars = heroStars[type] || 1;
                
                const baseStats = [
                    { attack: 50, attackSpeed: 1.0, range: 150, health: 500 }, // 관우
                    { attack: 40, attackSpeed: 0.8, range: 200, health: 400 }, // 제갈량
                    { attack: 60, attackSpeed: 1.2, range: 120, health: 600 }, // 장비
                    { attack: 55, attackSpeed: 1.5, range: 130, health: 450 }, // 조운
                    { attack: 45, attackSpeed: 1.0, range: 140, health: 500 }, // 유비
                    { attack: 70, attackSpeed: 1.3, range: 140, health: 550 }, // 여포
                    // 위(魏)
                    { attack: 65, attackSpeed: 1.1, range: 160, health: 520 }, // 조조
                    { attack: 58, attackSpeed: 1.3, range: 130, health: 580 }, // 하후돈
                    { attack: 56, attackSpeed: 1.4, range: 145, health: 540 }, // 장료
                    { attack: 62, attackSpeed: 1.0, range: 125, health: 650 }, // 허저
                    { attack: 57, attackSpeed: 1.2, range: 135, health: 560 }, // 하후연
                    { attack: 54, attackSpeed: 1.1, range: 140, health: 550 }, // 서황
                    { attack: 60, attackSpeed: 1.3, range: 132, health: 570 }, // 악진
                    { attack: 55, attackSpeed: 1.0, range: 128, health: 600 }, // 우금
                    { attack: 59, attackSpeed: 1.4, range: 143, health: 545 }, // 장합
                    { attack: 61, attackSpeed: 1.2, range: 130, health: 575 }, // 문추
                    { attack: 63, attackSpeed: 1.1, range: 127, health: 590 }, // 안량
                    // 촉(蜀)
                    { attack: 52, attackSpeed: 0.9, range: 180, health: 480 }, // 황충
                    { attack: 64, attackSpeed: 1.4, range: 135, health: 530 }, // 마초
                    { attack: 48, attackSpeed: 1.2, range: 140, health: 490 }, // 위연
                    { attack: 53, attackSpeed: 1.0, range: 165, health: 470 }, // 강유
                    { attack: 46, attackSpeed: 1.1, range: 145, health: 485 }, // 관평
                    { attack: 47, attackSpeed: 1.2, range: 142, health: 495 }, // 관흥
                    { attack: 49, attackSpeed: 1.3, range: 138, health: 505 }, // 장포
                    { attack: 50, attackSpeed: 1.1, range: 140, health: 500 }, // 마대
                    // 오(吳)
                    { attack: 50, attackSpeed: 1.0, range: 155, health: 510 }, // 손권
                    { attack: 42, attackSpeed: 0.9, range: 190, health: 420 }, // 주유
                    { attack: 59, attackSpeed: 1.3, range: 138, health: 520 }, // 감녕
                    { attack: 57, attackSpeed: 1.5, range: 142, health: 500 }, // 태사자
                    { attack: 58, attackSpeed: 1.2, range: 148, health: 515 }, // 여몽
                    { attack: 44, attackSpeed: 0.85, range: 185, health: 430 }, // 육손
                    { attack: 66, attackSpeed: 1.4, range: 152, health: 540 }, // 손책
                    { attack: 56, attackSpeed: 1.1, range: 136, health: 525 }, // 주태
                    { attack: 48, attackSpeed: 1.0, range: 144, health: 490 }, // 정봉
                    { attack: 55, attackSpeed: 0.95, range: 150, health: 580 }  // 황개
                ];
                
                const stats = baseStats[type] || baseStats[0];
                // 별 등급에 따른 능력치 보정 (1성 기준, 별당 20% 증가)
                const starMultiplier = 1 + (this.stars - 1) * 0.2;
                
                this.baseAttack = Math.floor(stats.attack * starMultiplier);
                this.baseAttackSpeed = stats.attackSpeed * (1 + (this.stars - 1) * 0.1);
                this.baseRange = Math.floor(stats.range * (1 + (this.stars - 1) * 0.1));
                this.maxHealth = Math.floor(stats.health * starMultiplier);
                this.health = this.maxHealth;
                
                // 장비 적용
                this.applyEquipment();
                
                this.skillCooldown = 0;
                this.skillCooldownMax = [
                    15, 20, 12, 10, 0, 25, // 기존 6명
                    18, 14, 13, 16, // 위(魏) 4명
                    16, 13, 11, // 촉(蜀) 3명
                    0, 22, 15, 14 // 오(吳) 4명
                ][type];
                this.attackBuff = 1.0;
                this.attackSpeedBuff = 1.0;
                this.buffTimer = 0;
                this.target = null;
                this.lastAttackTime = 0;
                this.attackAnimation = 0; // 공격 애니메이션 타이머 (0 = 대기, >0 = 공격 중)
                this.attackAngle = 0; // 공격 방향 각도
            }
            
            applyEquipment() {
                const equipment = heroEquipment[this.type] || {};
                for (const slot in equipment) {
                    const equipId = equipment[slot];
                    if (equipId && equipmentDatabase[equipId]) {
                        const equip = equipmentDatabase[equipId];
                        if (equip.attack) this.baseAttack += equip.attack;
                        if (equip.attackSpeed) this.baseAttackSpeed *= (1 + equip.attackSpeed);
                        if (equip.range) this.baseRange = Math.floor(this.baseRange * (1 + equip.range));
                        if (equip.health) {
                            const healthIncrease = equip.health;
                            this.maxHealth += healthIncrease;
                            this.health += healthIncrease;
                        }
                    }
                }
            }
            
            get attack() {
                return Math.floor(this.baseAttack * this.attackBuff);
            }
            
            get attackSpeed() {
                return this.baseAttackSpeed * this.attackSpeedBuff;
            }
            
            get range() {
                return this.baseRange;
            }
            
            update(dt, enemies) {
                if (this.buffTimer > 0) {
                    this.buffTimer -= dt;
                    if (this.buffTimer <= 0) {
                        this.attackBuff = 1.0;
                        this.attackSpeedBuff = 1.0;
                    }
                }
                
                if (this.skillCooldown > 0) {
                    this.skillCooldown -= dt;
                }
                
                // 공격 애니메이션 업데이트
                if (this.attackAnimation > 0) {
                    this.attackAnimation -= dt;
                    if (this.attackAnimation < 0) {
                        this.attackAnimation = 0;
                    }
                }
                
                this.findTarget(enemies);
                
                if (this.target && this.target.alive) {
                    // 타겟 방향 계산
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    this.attackAngle = Math.atan2(dy, dx);
                    
                    const currentTime = Date.now() / 1000;
                    if (currentTime - this.lastAttackTime >= 1.0 / this.attackSpeed) {
                        this.attackTarget();
                        this.lastAttackTime = currentTime;
                    }
                }
            }
            
            findTarget(enemies) {
                let closestEnemy = null;
                let closestDist = Infinity;
                
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range && dist < closestDist) {
                        closestEnemy = enemy;
                        closestDist = dist;
                    }
                }
                
                this.target = closestEnemy;
            }
            
            attackTarget() {
                if (this.target && this.target.alive) {
                    this.target.takeDamage(this.attack);
                    // 공격 애니메이션 시작 (0.3초)
                    this.attackAnimation = 0.3;
                }
            }
            
            useSkill(enemies, effects) {
                if (this.skillCooldown > 0) return false;
                
                this.skillCooldown = this.skillCooldownMax;
                
                switch (this.type) {
                    case HeroType.GUANYU:
                        return this.skillGuanYu(enemies, effects);
                    case HeroType.ZHUGELIANG:
                        return this.skillZhugeLiang(enemies, effects);
                    case HeroType.ZHANGFEI:
                        return this.skillZhangFei(enemies, effects);
                    case HeroType.ZHAOYUN:
                        return this.skillZhaoYun(enemies, effects);
                    case HeroType.LUBU:
                        return this.skillLuBu();
                    // 위(魏)
                    case HeroType.CAOCAO:
                        return this.skillCaoCao(enemies, effects);
                    case HeroType.XIAHOUDUN:
                        return this.skillXiahouDun(enemies, effects);
                    case HeroType.ZHANGLIAO:
                        return this.skillZhangLiao(enemies, effects);
                    case HeroType.XUZHU:
                        return this.skillXuZhu(enemies, effects);
                    // 촉(蜀)
                    case HeroType.HUANGZHONG:
                        return this.skillHuangZhong(enemies, effects);
                    case HeroType.MACHAO:
                        return this.skillMaChao(enemies, effects);
                    case HeroType.WEIYAN:
                        return this.skillWeiYan(enemies, effects);
                    // 오(吳)
                    case HeroType.SUNQUAN:
                        return false; // 패시브 스킬
                    case HeroType.ZHUYU:
                        return this.skillZhuYu(enemies, effects);
                    case HeroType.GANNING:
                        return this.skillGanNing(enemies, effects);
                    case HeroType.TAISHICI:
                        return this.skillTaiShiCi(enemies, effects);
                    default:
                        return false;
                }
            }
            
            skillGuanYu(enemies, effects) {
                const damage = this.attack * (3 + (this.stars - 1) * 0.5);
                let hitCount = 0;
                
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    
                    const dx = enemy.x - this.x;
                    const dy = enemy.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist <= this.range * 2) {
                        const angle = Math.atan2(dy, dx);
                        if (Math.abs(angle) < Math.PI / 6) {
                            if (enemy.takeDamage(Math.floor(damage))) {
                                hitCount++;
                            }
                        }
                    }
                }
                
                if (hitCount > 0) {
                    effects.push({
                        type: 'green_slash',
                        x: this.x,
                        y: this.y,
                        duration: 0.5,
                        timer: 0.5
                    });
                    return true;
                }
                return false;
            }
            
            skillZhugeLiang(enemies, effects) {
                const damage = Math.floor(this.attack * (2.5 + (this.stars - 1) * 0.3));
                const centerX = CANVAS_WIDTH / 2;
                const centerY = CANVAS_HEIGHT / 2;
                const radius = Math.min(200, CANVAS_WIDTH * 0.2) + (this.stars - 1) * 20;
                let hitCount = 0;
                
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    
                    const dist = Math.sqrt((enemy.x - centerX) ** 2 + (enemy.y - centerY) ** 2);
                    if (dist <= radius) {
                        if (enemy.takeDamage(damage)) {
                            hitCount++;
                        }
                    }
                }
                
                if (hitCount > 0) {
                    effects.push({
                        type: 'meteor',
                        x: centerX,
                        y: centerY,
                        duration: 1.0,
                        timer: 1.0
                    });
                    return true;
                }
                return false;
            }
            
            skillZhangFei(enemies, effects) {
                const damage = this.attack * (2 + (this.stars - 1) * 0.3);
                const radius = 150 + (this.stars - 1) * 15;
                let hitCount = 0;
                
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= radius) {
                        if (enemy.takeDamage(Math.floor(damage))) {
                            hitCount++;
                        } else {
                            enemy.speed *= 0.7;
                        }
                    }
                }
                
                if (hitCount > 0) {
                    effects.push({
                        type: 'shockwave',
                        x: this.x,
                        y: this.y,
                        duration: 0.8,
                        timer: 0.8
                    });
                    return true;
                }
                return false;
            }
            
            skillZhaoYun(enemies, effects) {
                let closest = null;
                let closestDist = Infinity;
                
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist < closestDist) {
                        closest = enemy;
                        closestDist = dist;
                    }
                }
                
                if (closest) {
                    const damage = this.attack * (4 + (this.stars - 1) * 0.5);
                    if (closest.takeDamage(Math.floor(damage))) {
                        effects.push({
                            type: 'charge',
                            startX: this.x,
                            startY: this.y,
                            endX: closest.x,
                            endY: closest.y,
                            duration: 0.5,
                            timer: 0.5
                        });
                        return true;
                    }
                }
                return false;
            }
            
            skillLuBu() {
                this.attackBuff = 2.0 + (this.stars - 1) * 0.2;
                this.attackSpeedBuff = 1.5 + (this.stars - 1) * 0.1;
                this.buffTimer = 10.0 + (this.stars - 1) * 1.0;
                return true;
            }
            
            // 위(魏) 스킬들
            skillCaoCao(enemies, effects) {
                const damage = Math.floor(this.attack * (2.5 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.5) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                if (hitCount > 0) {
                    effects.push({ type: 'shockwave', x: this.x, y: this.y, duration: 0.8, timer: 0.8 });
                    return true;
                }
                return false;
            }
            
            skillXiahouDun(enemies, effects) {
                const damage = Math.floor(this.attack * (2.8 + (this.stars - 1) * 0.4));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.3) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                this.attackBuff = 1.3 + (this.stars - 1) * 0.1;
                this.buffTimer = 8.0;
                return hitCount > 0;
            }
            
            skillZhangLiao(enemies, effects) {
                const damage = Math.floor(this.attack * (2.6 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.4) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                this.attackSpeedBuff = 1.4 + (this.stars - 1) * 0.1;
                this.buffTimer = 7.0;
                return hitCount > 0;
            }
            
            skillXuZhu(enemies, effects) {
                const damage = Math.floor(this.attack * (2.4 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                const closest = this.findClosestEnemy(enemies);
                if (closest) {
                    if (closest.takeDamage(damage * 1.5)) hitCount++;
                    effects.push({ type: 'charge', startX: this.x, startY: this.y, endX: closest.x, endY: closest.y, duration: 0.4, timer: 0.4 });
                }
                return hitCount > 0;
            }
            
            // 촉(蜀) 스킬들
            skillHuangZhong(enemies, effects) {
                const damage = Math.floor(this.attack * (3.0 + (this.stars - 1) * 0.5));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 2) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillMaChao(enemies, effects) {
                const damage = Math.floor(this.attack * (2.7 + (this.stars - 1) * 0.4));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.2) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                this.attackSpeedBuff = 1.5 + (this.stars - 1) * 0.1;
                this.buffTimer = 6.0;
                return hitCount > 0;
            }
            
            skillWeiYan(enemies, effects) {
                const damage = Math.floor(this.attack * (2.3 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.3) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            // 오(吳) 스킬들
            skillZhuYu(enemies, effects) {
                const damage = Math.floor(this.attack * (2.8 + (this.stars - 1) * 0.4));
                const centerX = CANVAS_WIDTH / 2;
                const centerY = CANVAS_HEIGHT / 2;
                const radius = Math.min(180, CANVAS_WIDTH * 0.18) + (this.stars - 1) * 15;
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - centerX) ** 2 + (enemy.y - centerY) ** 2);
                    if (dist <= radius) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                if (hitCount > 0) {
                    effects.push({ type: 'meteor', x: centerX, y: centerY, duration: 1.0, timer: 1.0 });
                    return true;
                }
                return false;
            }
            
            skillGanNing(enemies, effects) {
                const damage = Math.floor(this.attack * (2.9 + (this.stars - 1) * 0.4));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.5) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillTaiShiCi(enemies, effects) {
                const damage = Math.floor(this.attack * (2.6 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.6) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            // 위(魏) 추가 스킬들
            skillXiahouYuan(enemies, effects) {
                const damage = Math.floor(this.attack * (2.5 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.4) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillXuHuang(enemies, effects) {
                const damage = Math.floor(this.attack * (2.3 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.3) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillXuChu(enemies, effects) {
                const damage = Math.floor(this.attack * (2.7 + (this.stars - 1) * 0.4));
                let hitCount = 0;
                const closest = this.findClosestEnemy(enemies);
                if (closest) {
                    if (closest.takeDamage(damage * 1.8)) hitCount++;
                    effects.push({ type: 'charge', startX: this.x, startY: this.y, endX: closest.x, endY: closest.y, duration: 0.5, timer: 0.5 });
                }
                return hitCount > 0;
            }
            
            skillYuJin(enemies, effects) {
                const damage = Math.floor(this.attack * (2.2 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.2) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillYueJin(enemies, effects) {
                const damage = Math.floor(this.attack * (2.4 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.3) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillZhangHe(enemies, effects) {
                const damage = Math.floor(this.attack * (2.6 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.5) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                this.attackSpeedBuff = 1.3 + (this.stars - 1) * 0.1;
                this.buffTimer = 6.0;
                return hitCount > 0;
            }
            
            skillWenChou(enemies, effects) {
                const damage = Math.floor(this.attack * (2.8 + (this.stars - 1) * 0.4));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.3) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillYanLiang(enemies, effects) {
                const damage = Math.floor(this.attack * (2.7 + (this.stars - 1) * 0.4));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.4) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            // 촉(蜀) 추가 스킬들
            skillJiangWei(enemies, effects) {
                const damage = Math.floor(this.attack * (2.8 + (this.stars - 1) * 0.4));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.7) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillGuanPing(enemies, effects) {
                const damage = Math.floor(this.attack * (2.1 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.2) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillGuanXing(enemies, effects) {
                const damage = Math.floor(this.attack * (2.2 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.3) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillZhangBao(enemies, effects) {
                const damage = Math.floor(this.attack * (2.3 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.4) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillMaDai(enemies, effects) {
                const damage = Math.floor(this.attack * (2.0 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.2) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            // 오(吳) 추가 스킬들
            skillLuMeng(enemies, effects) {
                const damage = Math.floor(this.attack * (2.7 + (this.stars - 1) * 0.4));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.5) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillLuXun(enemies, effects) {
                const damage = Math.floor(this.attack * (2.9 + (this.stars - 1) * 0.4));
                const centerX = CANVAS_WIDTH / 2;
                const centerY = CANVAS_HEIGHT / 2;
                const radius = Math.min(170, CANVAS_WIDTH * 0.17) + (this.stars - 1) * 15;
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - centerX) ** 2 + (enemy.y - centerY) ** 2);
                    if (dist <= radius) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                if (hitCount > 0) {
                    effects.push({ type: 'meteor', x: centerX, y: centerY, duration: 1.0, timer: 1.0 });
                    return true;
                }
                return false;
            }
            
            skillSunCe(enemies, effects) {
                const damage = Math.floor(this.attack * (3.0 + (this.stars - 1) * 0.5));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.6) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                this.attackBuff = 1.4 + (this.stars - 1) * 0.1;
                this.buffTimer = 8.0;
                return hitCount > 0;
            }
            
            skillZhouTai(enemies, effects) {
                const damage = Math.floor(this.attack * (2.5 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.3) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillChengPu(enemies, effects) {
                const damage = Math.floor(this.attack * (2.1 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.2) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            skillHuangGai(enemies, effects) {
                const damage = Math.floor(this.attack * (2.6 + (this.stars - 1) * 0.3));
                let hitCount = 0;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist <= this.range * 1.4) {
                        if (enemy.takeDamage(damage)) hitCount++;
                    }
                }
                return hitCount > 0;
            }
            
            findClosestEnemy(enemies) {
                let closest = null;
                let closestDist = Infinity;
                for (const enemy of enemies) {
                    if (!enemy.alive) continue;
                    const dist = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (dist < closestDist) {
                        closest = enemy;
                        closestDist = dist;
                    }
                }
                return closest;
            }
            
            draw() {
                const size = 25 + (this.stars - 1) * 3;
                const scale = size / 30;
                
                // 그림자 효과
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.ellipse(this.x + 2, this.y + size + 2, size * 0.8, size * 0.3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // 공격 애니메이션에 따른 회전
                if (this.attackAnimation > 0) {
                    const animProgress = 1 - (this.attackAnimation / 0.3);
                    const rotation = Math.sin(animProgress * Math.PI) * 0.3; // 약간의 회전
                    ctx.rotate(this.attackAngle + rotation);
                } else if (this.target && this.target.alive) {
                    // 타겟을 향해 회전
                    ctx.rotate(this.attackAngle);
                }
                
                ctx.scale(scale, scale);
                
                // 각 영웅별 상세 일러스트 그리기
                this.drawHeroIllustration();
                
                ctx.restore();
                
                // 별 등급 표시
                ctx.fillStyle = COLORS.GOLD;
                ctx.font = `${Math.max(10, size * 0.5)}px Arial`;
                ctx.textAlign = 'center';
                ctx.strokeStyle = COLORS.BLACK;
                ctx.lineWidth = 2;
                ctx.strokeText('★'.repeat(this.stars), this.x, this.y - size - 10);
                ctx.fillText('★'.repeat(this.stars), this.x, this.y - size - 10);
                
                // 체력바
                const barWidth = size * 1.6;
                const barHeight = 6;
                const barX = this.x - barWidth / 2;
                const barY = this.y - size - 25;
                
                ctx.fillStyle = COLORS.BLACK;
                ctx.fillRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2);
                
                const healthRatio = this.health / this.maxHealth;
                ctx.fillStyle = healthRatio > 0.5 ? COLORS.GREEN : healthRatio > 0.25 ? COLORS.ORANGE : COLORS.RED;
                ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
                
                // 스킬 쿨타임 표시
                if (this.skillCooldown > 0) {
                    const cooldownRatio = this.skillCooldown / this.skillCooldownMax;
                    ctx.strokeStyle = COLORS.RED;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, size + 5, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * cooldownRatio);
                    ctx.stroke();
                }
            }
            
            drawHeroIllustration() {
                const type = this.type;
                
                switch(type) {
                    case 0: // 관우
                        this.drawGuanYu();
                        break;
                    case 1: // 제갈량
                        this.drawZhugeLiang();
                        break;
                    case 2: // 장비
                        this.drawZhangFei();
                        break;
                    case 3: // 조운
                        this.drawZhaoYun();
                        break;
                    case 4: // 유비
                        this.drawLiuBei();
                        break;
                    case 5: // 여포
                        this.drawLuBu();
                        break;
                    // 위(魏)
                    case 6: // 조조
                        this.drawCaoCao();
                        break;
                    case 7: // 하후돈
                        this.drawXiahouDun();
                        break;
                    case 8: // 장료
                        this.drawZhangLiao();
                        break;
                    case 9: // 허저
                        this.drawXuZhu();
                        break;
                    case 10: // 하후연
                        this.drawXiahouYuan();
                        break;
                    case 11: // 서황
                        this.drawXuHuang();
                        break;
                    case 12: // 악진
                        this.drawXuChu();
                        break;
                    case 13: // 우금
                        this.drawYuJin();
                        break;
                    case 14: // 장합
                        this.drawYueJin();
                        break;
                    case 15: // 문추
                        this.drawZhangHe();
                        break;
                    case 16: // 안량
                        this.drawWenChou();
                        break;
                    case 17: // 안량
                        this.drawYanLiang();
                        break;
                    // 촉(蜀)
                    case 18: // 황충
                        this.drawHuangZhong();
                        break;
                    case 19: // 마초
                        this.drawMaChao();
                        break;
                    case 20: // 위연
                        this.drawWeiYan();
                        break;
                    case 21: // 강유
                        this.drawJiangWei();
                        break;
                    case 22: // 관평
                        this.drawGuanPing();
                        break;
                    case 23: // 관흥
                        this.drawGuanXing();
                        break;
                    case 24: // 장포
                        this.drawZhangBao();
                        break;
                    case 25: // 마대
                        this.drawMaDai();
                        break;
                    // 오(吳)
                    case 26: // 손권
                        this.drawSunQuan();
                        break;
                    case 27: // 주유
                        this.drawZhuYu();
                        break;
                    case 28: // 감녕
                        this.drawGanNing();
                        break;
                    case 29: // 태사자
                        this.drawTaiShiCi();
                        break;
                    case 30: // 여몽
                        this.drawLuMeng();
                        break;
                    case 31: // 육손
                        this.drawLuXun();
                        break;
                    case 32: // 손책
                        this.drawSunCe();
                        break;
                    case 33: // 주태
                        this.drawZhouTai();
                        break;
                    case 34: // 정봉
                        this.drawChengPu();
                        break;
                    case 35: // 황개
                        this.drawHuangGai();
                        break;
                    default:
                        this.drawDefaultHero();
                }
            }
            
            drawGuanYu() {
                // 머리
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // 수염
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-8, -5);
                ctx.quadraticCurveTo(-12, 5, -10, 15);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(8, -5);
                ctx.quadraticCurveTo(12, 5, 10, 15);
                ctx.stroke();
                
                // 눈
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-4, -15, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(4, -15, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // 모자
                ctx.fillStyle = '#228b22';
                ctx.fillRect(-10, -25, 20, 8);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-8, -27, 16, 5);
                
                // 갑옷
                ctx.fillStyle = '#228b22';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-10, 0, 20, 6);
                
                // 청룡언월도 (공격 애니메이션 - 칼질 모션 강화)
                const attackProgress = this.attackAnimation > 0 ? 1 - (this.attackAnimation / 0.3) : 0;
                const swordAngle = attackProgress * Math.PI * 0.9; // 90도 회전 (더 큰 스윙)
                const swordLength = 15 + attackProgress * 6; // 공격 시 더 길어짐
                
                // 팔 움직임 (칼을 휘두르는 모션)
                const armAngle = attackProgress * Math.PI * 0.7;
                
                ctx.save();
                ctx.translate(-15, 5);
                ctx.rotate(armAngle); // 팔 회전
                ctx.translate(0, 0);
                ctx.rotate(swordAngle); // 칼 회전
                
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, swordLength);
                ctx.stroke();
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(0, swordLength, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 검기 이펙트 (더 강렬하게)
                if (attackProgress > 0.2 && attackProgress < 0.8) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, swordLength + 8);
                    ctx.stroke();
                    
                    // 검기 확장 이펙트
                    if (attackProgress > 0.3 && attackProgress < 0.7) {
                        ctx.strokeStyle = '#00ff00';
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = 0.4;
                        ctx.beginPath();
                        ctx.moveTo(-3, 0);
                        ctx.lineTo(-3, swordLength + 10);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(3, 0);
                        ctx.lineTo(3, swordLength + 10);
                        ctx.stroke();
                    }
                    ctx.globalAlpha = 1.0;
                }
                ctx.restore();
            }
            
            drawZhugeLiang() {
                // 머리
                ctx.fillStyle = '#d2b48c';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // 수염
                ctx.strokeStyle = '#d2b48c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-6, -5);
                ctx.quadraticCurveTo(-8, 8, -6, 18);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(6, -5);
                ctx.quadraticCurveTo(8, 8, 6, 18);
                ctx.stroke();
                
                // 눈
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-3, -15, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(3, -15, 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // 도사 모자
                ctx.fillStyle = '#4169e1';
                ctx.fillRect(-10, -25, 20, 10);
                ctx.fillStyle = '#000080';
                ctx.fillRect(-8, -27, 16, 6);
                
                // 도사 복장
                ctx.fillStyle = '#87ceeb';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-10, 0, 20, 5);
                
                // 부채 (공격 애니메이션 - 흔들림)
                const attackProgress = this.attackAnimation > 0 ? 1 - (this.attackAnimation / 0.3) : 0;
                const fanAngle = Math.sin(attackProgress * Math.PI * 4) * 0.3; // 빠르게 흔들림
                
                ctx.save();
                ctx.translate(15, 5);
                ctx.rotate(fanAngle);
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(7, -5);
                ctx.lineTo(7, 5);
                ctx.lineTo(0, 3);
                ctx.closePath();
                ctx.fill();
                
                // 마법 이펙트
                if (attackProgress > 0.2 && attackProgress < 0.8) {
                    ctx.fillStyle = '#87ceeb';
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(10, 0, 8 + attackProgress * 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
                ctx.restore();
            }
            
            drawZhangFei() {
                // 머리
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -15, 13, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴 (검은 피부)
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.arc(0, -12, 11, 0, Math.PI * 2);
                ctx.fill();
                
                // 눈 (크고 둥근)
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-5, -15, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(5, -15, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-5, -15, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(5, -15, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // 입
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(0, -8, 6, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 수염
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(-10, -5);
                ctx.quadraticCurveTo(-14, 8, -12, 20);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(10, -5);
                ctx.quadraticCurveTo(14, 8, 12, 20);
                ctx.stroke();
                
                // 투구
                ctx.fillStyle = '#006400';
                ctx.fillRect(-12, -28, 24, 10);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-10, -30, 20, 6);
                
                // 갑옷
                ctx.fillStyle = '#006400';
                ctx.fillRect(-13, -2, 26, 22);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-11, 0, 22, 7);
                
                // 창 (공격 애니메이션 - 더 강력한 모션)
                const attackProgress = this.attackAnimation > 0 ? 1 - (this.attackAnimation / 0.3) : 0;
                const spearAngle = attackProgress * Math.PI * 0.8; // 80도 회전 (더 큰 스윙)
                const spearLength = 15 + attackProgress * 5; // 공격 시 더 길어짐
                
                // 팔 움직임 (창을 휘두르는 모션)
                const armAngle = attackProgress * Math.PI * 0.6;
                
                ctx.save();
                ctx.translate(-18, 8);
                ctx.rotate(armAngle); // 팔 회전
                ctx.translate(0, 0);
                ctx.rotate(spearAngle); // 창 회전
                
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, spearLength);
                ctx.stroke();
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(0, spearLength, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 공격 이펙트 (더 강렬하게)
                if (attackProgress > 0.2 && attackProgress < 0.8) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, spearLength + 5);
                    ctx.stroke();
                    
                    // 충격파 이펙트
                    if (attackProgress > 0.4 && attackProgress < 0.7) {
                        ctx.fillStyle = '#ff0000';
                        ctx.globalAlpha = 0.3;
                        ctx.beginPath();
                        ctx.arc(0, spearLength + 3, 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1.0;
                }
                ctx.restore();
            }
            
            drawZhaoYun() {
                // 머리
                ctx.fillStyle = '#d2b48c';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // 눈
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-4, -15, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(4, -15, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // 투구
                ctx.fillStyle = '#4169e1';
                ctx.fillRect(-10, -25, 20, 8);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-8, -27, 16, 5);
                
                // 갑옷
                ctx.fillStyle = '#4169e1';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-10, 0, 20, 6);
                
                // 용창 (공격 애니메이션)
                const attackProgress = this.attackAnimation > 0 ? 1 - (this.attackAnimation / 0.3) : 0;
                const spearAngle = attackProgress * Math.PI * 0.4;
                const spearLength = 15 + attackProgress * 4;
                
                ctx.save();
                ctx.translate(-16, 5);
                ctx.rotate(spearAngle);
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, spearLength);
                ctx.stroke();
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(0, spearLength, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // 번개 이펙트
                if (attackProgress > 0.2 && attackProgress < 0.8) {
                    ctx.strokeStyle = '#4169e1';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, spearLength + 5);
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }
                ctx.restore();
            }
            
            drawLiuBei() {
                // 머리
                ctx.fillStyle = '#d2b48c';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // 눈
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-3, -15, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(3, -15, 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // 황제 관
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-10, -25, 20, 10);
                ctx.fillStyle = '#ff8c00';
                ctx.fillRect(-8, -27, 16, 6);
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(0, -28, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // 수염
                ctx.strokeStyle = '#d2b48c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-6, -5);
                ctx.quadraticCurveTo(-8, 10, -6, 20);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(6, -5);
                ctx.quadraticCurveTo(8, 10, 6, 20);
                ctx.stroke();
                
                // 황제 복장
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-10, 0, 20, 7);
                
                // 공격 애니메이션 (팔 흔들기)
                const attackProgress = this.attackAnimation > 0 ? 1 - (this.attackAnimation / 0.3) : 0;
                if (attackProgress > 0) {
                    const armAngle = Math.sin(attackProgress * Math.PI) * 0.4;
                    ctx.save();
                    ctx.translate(-10, 5);
                    ctx.rotate(armAngle);
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(0, 0, 4, 8);
                    ctx.restore();
                    
                    ctx.save();
                    ctx.translate(10, 5);
                    ctx.rotate(-armAngle);
                    ctx.fillStyle = '#ffd700';
                    ctx.fillRect(-4, 0, 4, 8);
                    ctx.restore();
                }
            }
            
            drawLuBu() {
                // 머리
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -15, 13, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.arc(0, -12, 11, 0, Math.PI * 2);
                ctx.fill();
                
                // 눈
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(-5, -15, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(5, -15, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-5, -15, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(5, -15, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // 투구
                ctx.fillStyle = '#9370db';
                ctx.fillRect(-12, -28, 24, 10);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-10, -30, 20, 6);
                
                // 수염
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-8, -5);
                ctx.quadraticCurveTo(-10, 10, -8, 20);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(8, -5);
                ctx.quadraticCurveTo(10, 10, 8, 20);
                ctx.stroke();
                
                // 갑옷
                ctx.fillStyle = '#9370db';
                ctx.fillRect(-13, -2, 26, 22);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-11, 0, 22, 7);
                
                // 방천화극 (공격 애니메이션)
                const attackProgress = this.attackAnimation > 0 ? 1 - (this.attackAnimation / 0.3) : 0;
                const halberdAngle = attackProgress * Math.PI * 0.7; // 강력한 회전
                const halberdLength = 18 + attackProgress * 5;
                
                ctx.save();
                ctx.translate(-18, 8);
                ctx.rotate(halberdAngle);
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, halberdLength);
                ctx.stroke();
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(0, halberdLength, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 강력한 공격 이펙트
                if (attackProgress > 0.2 && attackProgress < 0.8) {
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, halberdLength + 8);
                    ctx.stroke();
                    ctx.fillStyle = '#ff0000';
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.arc(0, halberdLength + 5, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
                ctx.restore();
            }
            
            drawDefaultHero() {
                const color = HeroColors[this.type] || COLORS.WHITE;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(0, 0, 15, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // 위(魏) 일러스트들
            drawCaoCao() {
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-10, 0, 20, 6);
            }
            
            drawXiahouDun() {
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#dc143c';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-15, 5);
                ctx.lineTo(-25, 20);
                ctx.stroke();
            }
            
            drawZhangLiao() {
                ctx.fillStyle = '#d2b48c';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff6347';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-16, 5);
                ctx.lineTo(-26, 22);
                ctx.stroke();
            }
            
            drawXuZhu() {
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -15, 13, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.arc(0, -12, 11, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff4500';
                ctx.fillRect(-13, -2, 26, 22);
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(-18, 8);
                ctx.lineTo(-28, 25);
                ctx.stroke();
            }
            
            // 촉(蜀) 일러스트들
            drawHuangZhong() {
                // 머리
                ctx.fillStyle = '#d2b48c';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // 눈
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-3, -15, 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(3, -15, 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // 수염
                ctx.strokeStyle = '#d2b48c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(-6, -5);
                ctx.quadraticCurveTo(-8, 5, -6, 15);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(6, -5);
                ctx.quadraticCurveTo(8, 5, 6, 15);
                ctx.stroke();
                
                // 갑옷
                ctx.fillStyle = '#ffa500';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-10, 0, 20, 6);
                
                // 활 (공격 애니메이션)
                const attackProgress = this.attackAnimation > 0 ? 1 - (this.attackAnimation / 0.3) : 0;
                const bowAngle = this.attackAngle + (attackProgress > 0 ? Math.sin(attackProgress * Math.PI) * 0.2 : 0);
                const drawProgress = attackProgress > 0.1 && attackProgress < 0.5 ? (attackProgress - 0.1) / 0.4 : 0;
                
                ctx.save();
                ctx.translate(8, -2);
                ctx.rotate(bowAngle);
                
                // 활 몸체
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI);
                ctx.stroke();
                
                // 활시위 (당기는 모션)
                if (drawProgress > 0) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-8, 0);
                    ctx.lineTo(-8 + drawProgress * 16, -drawProgress * 12);
                    ctx.lineTo(8, 0);
                    ctx.stroke();
                    
                    // 화살
                    ctx.save();
                    ctx.translate(-8 + drawProgress * 16, -drawProgress * 12);
                    ctx.rotate(Math.atan2(-drawProgress * 12, drawProgress * 16));
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(8, -1);
                    ctx.lineTo(8, 1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(8, 0, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else {
                    // 기본 활시위
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(-8, 0);
                    ctx.lineTo(8, 0);
                    ctx.stroke();
                }
                
                ctx.restore();
                
                // 공격 시 화살 발사 이펙트
                if (attackProgress > 0.5 && attackProgress < 0.8 && this.target) {
                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const arrowProgress = (attackProgress - 0.5) / 0.3;
                    const arrowX = this.x + (dx / dist) * arrowProgress * Math.min(dist, this.range);
                    const arrowY = this.y + (dy / dist) * arrowProgress * Math.min(dist, this.range);
                    const arrowAngle = Math.atan2(dy, dx);
                    
                    ctx.save();
                    ctx.translate(arrowX - this.x, arrowY - this.y);
                    ctx.rotate(arrowAngle);
                    ctx.fillStyle = '#654321';
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(6, -1);
                    ctx.lineTo(6, 1);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = '#ffd700';
                    ctx.beginPath();
                    ctx.arc(6, 0, 1, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            drawMaChao() {
                ctx.fillStyle = '#d2b48c';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#ff8c00';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-16, 5);
                ctx.lineTo(-26, 22);
                ctx.stroke();
            }
            
            drawWeiYan() {
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#daa520';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-15, 5);
                ctx.lineTo(-25, 20);
                ctx.stroke();
            }
            
            // 오(吳) 일러스트들
            drawSunQuan() {
                ctx.fillStyle = '#d2b48c';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#4169e1';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-10, 0, 20, 6);
            }
            
            drawZhuYu() {
                ctx.fillStyle = '#d2b48c';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#1e90ff';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.moveTo(15, 5);
                ctx.lineTo(22, 0);
                ctx.lineTo(22, 10);
                ctx.lineTo(15, 8);
                ctx.closePath();
                ctx.fill();
            }
            
            drawGanNing() {
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#00bfff';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-15, 5);
                ctx.lineTo(-25, 20);
                ctx.stroke();
            }
            
            drawTaiShiCi() {
                ctx.fillStyle = '#d2b48c';
                ctx.beginPath();
                ctx.arc(0, -15, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -12, 10, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#87ceeb';
                ctx.fillRect(-12, -2, 24, 20);
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(8, -2, 8, 0, Math.PI);
                ctx.stroke();
            }
            
            // 위(魏) 추가 일러스트들
            drawXiahouYuan() { this.drawXiahouDun(); }
            drawXuHuang() { this.drawZhangLiao(); }
            drawXuChu() { this.drawXuZhu(); }
            drawYuJin() { this.drawXiahouDun(); }
            drawYueJin() { this.drawZhangLiao(); }
            drawZhangHe() { this.drawXiahouDun(); }
            drawWenChou() { this.drawXuZhu(); }
            drawYanLiang() { this.drawXiahouDun(); }
            
            // 촉(蜀) 추가 일러스트들
            drawJiangWei() { this.drawZhugeLiang(); }
            drawGuanPing() { this.drawGuanYu(); }
            drawGuanXing() { this.drawGuanYu(); }
            drawZhangBao() { this.drawZhangFei(); }
            drawMaDai() { this.drawMaChao(); }
            
            // 오(吳) 추가 일러스트들
            drawLuMeng() { this.drawZhuYu(); }
            drawLuXun() { this.drawZhugeLiang(); }
            drawSunCe() { this.drawSunQuan(); }
            drawZhouTai() { this.drawGanNing(); }
            drawChengPu() { this.drawTaiShiCi(); }
            drawHuangGai() { this.drawTaiShiCi(); }
        }

        // 유닛 클래스 (기존과 동일)
        class Unit {
            constructor(x, y, type, round) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.round = round;
                
                const baseStats = {
                    [UnitType.SOLDIER]: { health: 100, attack: 10, speed: 1.0 },
                    [UnitType.ARCHER]: { health: 80, attack: 15, speed: 1.5 },
                    [UnitType.CAVALRY]: { health: 150, attack: 20, speed: 2.5 },
                    [UnitType.SPEARMAN]: { health: 120, attack: 25, speed: 1.2 },
                    [UnitType.DRAGON]: { health: 200, attack: 30, speed: 1.0 },
                    [UnitType.SHIELDMAN]: { health: 300, attack: 15, speed: 0.8 },
                    [UnitType.BOSS]: { health: 1000, attack: 50, speed: 1.0 }
                };
                
                const stats = baseStats[type] || baseStats[UnitType.SOLDIER];
                const multiplier = 1 + round * 0.15;
                
                this.maxHealth = Math.floor(stats.health * multiplier);
                this.health = this.maxHealth;
                this.attack = Math.floor(stats.attack * (1 + round * 0.12));
                this.speed = stats.speed * (1 + round * 0.08);
                this.isFlying = type === UnitType.DRAGON;
                this.goldReward = Math.floor(10 * (1 + round * 0.1));
                this.treasureReward = type === UnitType.BOSS ? Math.floor(Math.random() * 3) + 3 : 0;
                this.alive = true;
                this.pathIndex = 0;
                this.path = this.generatePath();
                this.walkAnimation = 0; // 걷기 애니메이션 (0~1)
                this.lastX = x;
                this.lastY = y;
                this.direction = 0; // 이동 방향 각도
            }
            
            generatePath() {
                // 현재 Canvas 크기에 맞춰 경로 생성 (getPathPoints 함수 사용)
                return getPathPoints();
            }
            
            update(dt) {
                if (!this.alive) return;
                
                if (this.pathIndex < this.path.length - 1) {
                    const target = this.path[this.pathIndex + 1];
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 10) {
                        this.pathIndex++;
                    } else {
                        // 이동 방향 계산
                        this.direction = Math.atan2(dy, dx);
                        
                        const moveDist = this.speed * dt * 60;
                        const oldX = this.x;
                        const oldY = this.y;
                        this.x += (dx / dist) * moveDist;
                        this.y += (dy / dist) * moveDist;
                        
                        // 걷기 애니메이션 업데이트
                        const movedDist = Math.sqrt((this.x - oldX) ** 2 + (this.y - oldY) ** 2);
                        this.walkAnimation += movedDist * 0.1;
                        if (this.walkAnimation > Math.PI * 2) {
                            this.walkAnimation -= Math.PI * 2;
                        }
                    }
                } else {
                    this.alive = false;
                }
            }
            
            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    this.alive = false;
                    return true;
                }
                return false;
            }
            
            draw() {
                if (!this.alive) return;
                
                const size = this.type === UnitType.BOSS ? 28 : this.type === UnitType.DRAGON ? 20 : 14;
                const scale = size / 15;
                
                // 그림자 효과
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(this.x + 1, this.y + size + 1, size * 0.7, size * 0.2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // 이동 방향에 따라 회전
                ctx.rotate(this.direction);
                
                ctx.scale(scale, scale);
                
                // 각 몬스터 타입별 상세 일러스트 그리기
                this.drawMonsterIllustration();
                
                ctx.restore();
                
                // 체력바
                const barWidth = size * 2.2;
                const barHeight = 5;
                const barX = this.x - barWidth / 2;
                const barY = this.y - size - 12;
                
                ctx.fillStyle = COLORS.BLACK;
                ctx.fillRect(barX - 1, barY - 1, barWidth + 2, barHeight + 2);
                
                const healthRatio = this.health / this.maxHealth;
                ctx.fillStyle = healthRatio > 0.5 ? COLORS.GREEN : healthRatio > 0.25 ? COLORS.ORANGE : COLORS.RED;
                ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
            }
            
            drawMonsterIllustration() {
                switch(this.type) {
                    case UnitType.SOLDIER:
                        this.drawSoldier();
                        break;
                    case UnitType.ARCHER:
                        this.drawArcher();
                        break;
                    case UnitType.CAVALRY:
                        this.drawCavalry();
                        break;
                    case UnitType.SPEARMAN:
                        this.drawSpearman();
                        break;
                    case UnitType.DRAGON:
                        this.drawDragon();
                        break;
                    case UnitType.SHIELDMAN:
                        this.drawShieldman();
                        break;
                    case UnitType.BOSS:
                        this.drawBoss();
                        break;
                    default:
                        this.drawDefaultMonster();
                }
            }
            
            drawSoldier() {
                // 몸통
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(-6, -5, 12, 15);
                
                // 머리
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -10, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -10, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // 눈
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-2, -11, 1, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(2, -11, 1, 0, Math.PI * 2);
                ctx.fill();
                
                // 투구
                ctx.fillStyle = '#654321';
                ctx.fillRect(-7, -16, 14, 6);
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(-5, -18, 10, 4);
                
                // 팔 (걷기 애니메이션)
                const armSwing = Math.sin(this.walkAnimation) * 0.3;
                ctx.save();
                ctx.translate(-8, -3);
                ctx.rotate(armSwing);
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(0, 0, 4, 10);
                ctx.restore();
                
                ctx.save();
                ctx.translate(4, -3);
                ctx.rotate(-armSwing);
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(0, 0, 4, 10);
                ctx.restore();
                
                // 검
                ctx.strokeStyle = '#c0c0c0';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(8, 0);
                ctx.lineTo(12, -5);
                ctx.stroke();
                
                // 다리 (걷기 애니메이션)
                const legSwing = Math.sin(this.walkAnimation) * 0.4;
                ctx.save();
                ctx.translate(-4, 10);
                ctx.rotate(legSwing);
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, 3, 8);
                ctx.restore();
                
                ctx.save();
                ctx.translate(1, 10);
                ctx.rotate(-legSwing);
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, 3, 8);
                ctx.restore();
            }
            
            drawArcher() {
                // 몸통
                ctx.fillStyle = '#ff8c00';
                ctx.fillRect(-5, -5, 10, 14);
                
                // 머리
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -10, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -10, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 눈
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-1.5, -10.5, 0.8, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(1.5, -10.5, 0.8, 0, Math.PI * 2);
                ctx.fill();
                
                // 모자
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(-6, -15, 12, 5);
                
                // 활
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(8, -2, 8, 0, Math.PI);
                ctx.stroke();
                
                // 팔 (걷기 애니메이션)
                const armSwing = Math.sin(this.walkAnimation) * 0.3;
                ctx.save();
                ctx.translate(-7, -3);
                ctx.rotate(armSwing);
                ctx.fillStyle = '#ff8c00';
                ctx.fillRect(0, 0, 3, 9);
                ctx.restore();
                
                ctx.save();
                ctx.translate(4, -3);
                ctx.rotate(-armSwing);
                ctx.fillStyle = '#ff8c00';
                ctx.fillRect(0, 0, 3, 9);
                ctx.restore();
                
                // 다리 (걷기 애니메이션)
                const legSwing = Math.sin(this.walkAnimation) * 0.3;
                ctx.save();
                ctx.translate(-3, 9);
                ctx.rotate(legSwing);
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, 2, 7);
                ctx.restore();
                
                ctx.save();
                ctx.translate(1, 9);
                ctx.rotate(-legSwing);
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, 2, 7);
                ctx.restore();
            }
            
            drawCavalry() {
                // 말 (걷기 애니메이션)
                const horseBounce = Math.sin(this.walkAnimation * 2) * 0.2;
                ctx.save();
                ctx.translate(0, horseBounce);
                
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.ellipse(0, 5, 10, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 말 머리
                ctx.beginPath();
                ctx.arc(-8, 2, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 말 눈
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-9, 1.5, 1, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
                
                // 기병
                ctx.fillStyle = '#9370db';
                ctx.fillRect(-4, -8, 8, 12);
                
                // 머리
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -10, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -10, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 투구
                ctx.fillStyle = '#9370db';
                ctx.fillRect(-5, -15, 10, 5);
                
                // 창
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(6, -5);
                ctx.lineTo(15, -15);
                ctx.stroke();
            }
            
            drawSpearman() {
                // 몸통
                ctx.fillStyle = '#4169e1';
                ctx.fillRect(-6, -5, 12, 15);
                
                // 머리
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -10, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(0, -10, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // 눈
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-2, -11, 1, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(2, -11, 1, 0, Math.PI * 2);
                ctx.fill();
                
                // 투구
                ctx.fillStyle = '#4169e1';
                ctx.fillRect(-7, -16, 14, 6);
                
                // 창
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(8, -2);
                ctx.lineTo(18, -12);
                ctx.stroke();
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(18, -12, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // 팔 (걷기 애니메이션)
                const armSwing = Math.sin(this.walkAnimation) * 0.3;
                ctx.save();
                ctx.translate(-8, -3);
                ctx.rotate(armSwing);
                ctx.fillStyle = '#4169e1';
                ctx.fillRect(0, 0, 4, 10);
                ctx.restore();
                
                ctx.save();
                ctx.translate(4, -3);
                ctx.rotate(-armSwing);
                ctx.fillStyle = '#4169e1';
                ctx.fillRect(0, 0, 4, 10);
                ctx.restore();
                
                // 다리 (걷기 애니메이션)
                const legSwing = Math.sin(this.walkAnimation) * 0.4;
                ctx.save();
                ctx.translate(-4, 10);
                ctx.rotate(legSwing);
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, 3, 8);
                ctx.restore();
                
                ctx.save();
                ctx.translate(1, 10);
                ctx.rotate(-legSwing);
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, 3, 8);
                ctx.restore();
            }
            
            drawDragon() {
                // 날개 애니메이션
                const wingFlap = Math.sin(this.walkAnimation * 2) * 0.3;
                
                // 몸통
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.ellipse(0, 0, 12, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 머리
                ctx.beginPath();
                ctx.arc(-10, -5, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // 눈
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(-11, -6, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(-9, -6, 2, 0, Math.PI * 2);
                ctx.fill();
                
                // 뿔
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.moveTo(-12, -10);
                ctx.lineTo(-14, -15);
                ctx.lineTo(-10, -12);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(-8, -10);
                ctx.lineTo(-6, -15);
                ctx.lineTo(-10, -12);
                ctx.closePath();
                ctx.fill();
                
                // 날개 (움직임)
                ctx.save();
                ctx.translate(5, -3);
                ctx.rotate(wingFlap);
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(7, -5);
                ctx.lineTo(5, 5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                
                ctx.save();
                ctx.translate(5, 3);
                ctx.rotate(-wingFlap);
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(7, 5);
                ctx.lineTo(5, -5);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
                
                // 꼬리 (흔들림)
                const tailSwing = Math.sin(this.walkAnimation * 1.5) * 0.2;
                ctx.save();
                ctx.translate(10, 0);
                ctx.rotate(tailSwing);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.quadraticCurveTo(5, 5, 8, 0);
                ctx.stroke();
                ctx.restore();
            }
            
            drawShieldman() {
                // 방패
                ctx.fillStyle = '#c0c0c0';
                ctx.fillRect(-10, -8, 8, 12);
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 2;
                ctx.strokeRect(-10, -8, 8, 12);
                
                // 몸통
                ctx.fillStyle = '#646464';
                ctx.fillRect(-4, -5, 8, 14);
                
                // 머리
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(2, -10, 5, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#fdbcb4';
                ctx.beginPath();
                ctx.arc(2, -10, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 눈
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(1, -11, 1, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(3, -11, 1, 0, Math.PI * 2);
                ctx.fill();
                
                // 투구
                ctx.fillStyle = '#646464';
                ctx.fillRect(-3, -15, 10, 5);
                
                // 팔 (걷기 애니메이션)
                const armSwing = Math.sin(this.walkAnimation) * 0.2;
                ctx.save();
                ctx.translate(-6, -3);
                ctx.rotate(armSwing);
                ctx.fillStyle = '#646464';
                ctx.fillRect(0, 0, 3, 10);
                ctx.restore();
                
                ctx.save();
                ctx.translate(4, -3);
                ctx.rotate(-armSwing);
                ctx.fillStyle = '#646464';
                ctx.fillRect(0, 0, 3, 10);
                ctx.restore();
                
                // 다리 (걷기 애니메이션)
                const legSwing = Math.sin(this.walkAnimation) * 0.3;
                ctx.save();
                ctx.translate(-2, 9);
                ctx.rotate(legSwing);
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, 2, 8);
                ctx.restore();
                
                ctx.save();
                ctx.translate(2, 9);
                ctx.rotate(-legSwing);
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, 2, 8);
                ctx.restore();
            }
            
            drawBoss() {
                // 큰 몸통
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(-10, -8, 20, 20);
                
                // 머리
                ctx.fillStyle = '#8b4513';
                ctx.beginPath();
                ctx.arc(0, -15, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // 얼굴
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.arc(0, -15, 7, 0, Math.PI * 2);
                ctx.fill();
                
                // 큰 눈
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(-3, -16, 2.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(3, -16, 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // 입
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.ellipse(0, -12, 4, 2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 화려한 투구
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-12, -23, 24, 8);
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-10, -25, 20, 5);
                
                // 갑옷 장식
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-8, -6, 16, 4);
                ctx.fillRect(-8, 2, 16, 4);
                
                // 큰 무기
                ctx.strokeStyle = '#8b4513';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(12, 0);
                ctx.lineTo(22, -10);
                ctx.stroke();
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(22, -10, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // 팔 (걷기 애니메이션)
                const armSwing = Math.sin(this.walkAnimation) * 0.2;
                ctx.save();
                ctx.translate(-12, -5);
                ctx.rotate(armSwing);
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(0, 0, 5, 12);
                ctx.restore();
                
                ctx.save();
                ctx.translate(7, -5);
                ctx.rotate(-armSwing);
                ctx.fillStyle = '#8b0000';
                ctx.fillRect(0, 0, 5, 12);
                ctx.restore();
                
                // 다리 (걷기 애니메이션)
                const legSwing = Math.sin(this.walkAnimation) * 0.3;
                ctx.save();
                ctx.translate(-6, 12);
                ctx.rotate(legSwing);
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, 4, 10);
                ctx.restore();
                
                ctx.save();
                ctx.translate(2, 12);
                ctx.rotate(-legSwing);
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, 0, 4, 10);
                ctx.restore();
            }
            
            drawDefaultMonster() {
                ctx.fillStyle = COLORS.RED;
                ctx.beginPath();
                ctx.arc(0, 0, 10, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // 경로 포인트 가져오기 (다른 함수에서도 사용)
        function getPathPoints() {
            return [
                { x: 0, y: CANVAS_HEIGHT / 2 },
                { x: CANVAS_WIDTH / 3, y: CANVAS_HEIGHT / 2 },
                { x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 3 },
                { x: CANVAS_WIDTH * 2 / 3, y: CANVAS_HEIGHT / 3 },
                { x: CANVAS_WIDTH, y: CANVAS_HEIGHT / 2 }
            ];
        }
        
        // 경로와의 거리 계산 (점에서 선분까지의 최단 거리)
        function distanceToLineSegment(point, lineStart, lineEnd) {
            const A = point.x - lineStart.x;
            const B = point.y - lineStart.y;
            const C = lineEnd.x - lineStart.x;
            const D = lineEnd.y - lineStart.y;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) {
                param = dot / lenSq;
            }
            
            let xx, yy;
            
            if (param < 0) {
                xx = lineStart.x;
                yy = lineStart.y;
            } else if (param > 1) {
                xx = lineEnd.x;
                yy = lineEnd.y;
            } else {
                xx = lineStart.x + param * C;
                yy = lineStart.y + param * D;
            }
            
            const dx = point.x - xx;
            const dy = point.y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        // 경로 위에 있는지 확인 (경로 너비 고려)
        function isOnPath(x, y, pathWidth = 40) {
            const pathPoints = getPathPoints();
            
            for (let i = 0; i < pathPoints.length - 1; i++) {
                const dist = distanceToLineSegment(
                    { x, y },
                    pathPoints[i],
                    pathPoints[i + 1]
                );
                
                if (dist < pathWidth) {
                    return true;
                }
            }
            
            return false;
        }
        
        // 경로 그리기
        function drawPath() {
            const pathPoints = getPathPoints();
            
            ctx.strokeStyle = '#646464';
            ctx.lineWidth = Math.max(3, CANVAS_WIDTH / 240); // 반응형 선 두께
            ctx.beginPath();
            ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
            for (let i = 1; i < pathPoints.length; i++) {
                ctx.lineTo(pathPoints[i].x, pathPoints[i].y);
            }
            ctx.stroke();
        }

        // 이펙트 그리기
        function drawEffects() {
            for (let i = effects.length - 1; i >= 0; i--) {
                const effect = effects[i];
                effect.timer -= 1/60;
                
                if (effect.timer <= 0) {
                    effects.splice(i, 1);
                    continue;
                }
                
                switch (effect.type) {
                    case 'green_slash':
                        ctx.strokeStyle = COLORS.GREEN;
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(effect.x, effect.y);
                        ctx.lineTo(effect.x + 300, effect.y);
                        ctx.stroke();
                        break;
                    case 'meteor':
                        ctx.fillStyle = COLORS.ORANGE;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, 50, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = COLORS.YELLOW;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, 30, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'shockwave':
                        const radius = Math.floor(150 * (1 - effect.timer / effect.duration));
                        ctx.strokeStyle = COLORS.BLUE;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(effect.x, effect.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                        break;
                    case 'charge':
                        ctx.strokeStyle = COLORS.YELLOW;
                        ctx.lineWidth = 5;
                        ctx.beginPath();
                        ctx.moveTo(effect.startX, effect.startY);
                        ctx.lineTo(effect.endX, effect.endY);
                        ctx.stroke();
                        break;
                }
            }
        }

        // 적 스폰
        function spawnEnemy() {
            if (enemiesSpawned >= enemiesPerWave) return;
            
            let unitTypes = [];
            if (roundNum < 5) {
                unitTypes = [UnitType.SOLDIER, UnitType.ARCHER];
            } else if (roundNum < 10) {
                unitTypes = [UnitType.SOLDIER, UnitType.ARCHER, UnitType.CAVALRY, UnitType.SPEARMAN];
            } else {
                unitTypes = [UnitType.SOLDIER, UnitType.ARCHER, UnitType.CAVALRY, UnitType.SPEARMAN, UnitType.DRAGON, UnitType.SHIELDMAN];
            }
            
            let unitType;
            if (roundNum % 10 === 0 && enemiesSpawned === 0) {
                unitType = UnitType.BOSS;
            } else {
                unitType = unitTypes[Math.floor(Math.random() * unitTypes.length)];
            }
            
            const enemy = new Unit(0, CANVAS_HEIGHT / 2, unitType, roundNum);
            enemies.push(enemy);
            enemiesSpawned++;
        }

        // 라운드 시작
        function startRound() {
            enemiesSpawned = 0;
            enemiesPerWave = 5 + Math.floor(roundNum / 2);
            waveTimer = 0;
        }

        // 게임 업데이트
        function update(dt) {
            if (gameState !== 'PLAYING') return;
            
            if (enemiesSpawned < enemiesPerWave) {
                waveTimer += dt;
                if (waveTimer >= waveInterval) {
                    spawnEnemy();
                    waveTimer = 0;
                }
            }
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.update(dt);
                
                if (!enemy.alive) {
                    if (enemy.x >= CANVAS_WIDTH) {
                        gameOver = true;
                        gameState = 'GAME_OVER';
                    } else {
                        gold += enemy.goldReward;
                        treasure += enemy.treasureReward;
                    }
                    enemies.splice(i, 1);
                }
            }
            
            for (const hero of heroes) {
                hero.update(dt, enemies);
            }
            
            for (let i = effects.length - 1; i >= 0; i--) {
                effects[i].timer -= dt;
                if (effects[i].timer <= 0) {
                    effects.splice(i, 1);
                }
            }
            
            if (enemies.length === 0 && enemiesSpawned >= enemiesPerWave) {
                roundNum++;
                startRound();
            }
            
            if (roundNum > 30) {
                victory = true;
                gameState = 'VICTORY';
            }
            
            updateUI();
        }

        function updateUI() {
            document.getElementById('goldAmount').textContent = gold;
            document.getElementById('treasureAmount').textContent = treasure;
            document.getElementById('roundNumber').textContent = roundNum;
        }

        // 게임 시작 함수
        function startGame() {
            document.getElementById('introScreen').classList.add('hidden');
            gameState = 'PLAYING';
            startRound();
        }
        
        // 게임 그리기
        function draw() {
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            if (gameState === 'MENU') {
                // 인트로 화면이 표시되므로 여기서는 아무것도 그리지 않음
            } else if (gameState === 'PLAYING') {
                drawPath();
                
                for (const hero of heroes) {
                    hero.draw();
                }
                
                for (const enemy of enemies) {
                    enemy.draw();
                }
                
                drawEffects();
                
                if (gameOver) {
                    ctx.fillStyle = COLORS.RED;
                    ctx.font = '48px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('게임 오버!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
                }
            } else if (gameState === 'VICTORY') {
                ctx.fillStyle = COLORS.GOLD;
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('승리!', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            }
        }

        // 게임 루프
        let lastTime = 0;
        function gameLoop(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;
            
            update(dt);
            draw();
            
            requestAnimationFrame(gameLoop);
        }

        // 터치/클릭 좌표 변환 함수
        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0);
            const clientY = e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0);
            
            const scaleX = CANVAS_WIDTH / rect.width;
            const scaleY = CANVAS_HEIGHT / rect.height;
            
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }
        
        // 이벤트 리스너
        canvas.addEventListener('click', (e) => {
            if (gameState !== 'PLAYING') return;
            
            const coords = getCanvasCoordinates(e);
            const x = coords.x;
            const y = coords.y;
            
            if (placingHeroType !== null) {
                // 같은 타입의 영웅이 이미 배치되어 있는지 확인
                const existingHero = heroes.find(h => h.type === placingHeroType);
                if (existingHero) {
                    alert(`${HeroNames[placingHeroType]}은(는) 이미 배치되어 있습니다! 같은 영웅은 1개만 배치할 수 있습니다.`);
                    return;
                }
                
                // 경로 위에 있는지 확인
                if (isOnPath(x, y)) {
                    alert('몬스터가 지나가는 길 위에는 영웅을 배치할 수 없습니다!');
                    return;
                }
                
                // 다른 영웅과 겹치는지 확인
                const minDistance = 50; // 최소 거리
                for (const hero of heroes) {
                    const dist = Math.sqrt((hero.x - x) ** 2 + (hero.y - y) ** 2);
                    if (dist < minDistance) {
                        alert('다른 영웅과 너무 가깝습니다!');
                        return;
                    }
                }
                
                const totalCards = getTotalHeroCards(placingHeroType);
                if (totalCards === 0 && (!heroStars[placingHeroType] || heroStars[placingHeroType] === 1)) {
                    alert('영웅 카드가 없습니다! 상점에서 소환하세요.');
                    return;
                }
                
                const hero = new Hero(x, y, placingHeroType);
                heroes.push(hero);
                placingHeroType = null;
                document.querySelectorAll('.hero-btn').forEach(btn => btn.classList.remove('selected'));
            } else {
                for (const hero of heroes) {
                    const dist = Math.sqrt((hero.x - x) ** 2 + (hero.y - y) ** 2);
                    if (dist < 20) {
                        selectedHero = hero;
                        break;
                    }
                }
            }
        });
        
        // 모바일 스크롤 방지
        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas || e.target.closest('#gameContainer')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchstart', (e) => {
            if (e.target === canvas || e.target.closest('#gameContainer')) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // 터치 이벤트 지원
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (gameState !== 'PLAYING') return;
            
            const coords = getCanvasCoordinates(e);
            const x = coords.x;
            const y = coords.y;
            
            if (placingHeroType !== null) {
                // 같은 타입의 영웅이 이미 배치되어 있는지 확인
                const existingHero = heroes.find(h => h.type === placingHeroType);
                if (existingHero) {
                    alert(`${HeroNames[placingHeroType]}은(는) 이미 배치되어 있습니다! 같은 영웅은 1개만 배치할 수 있습니다.`);
                    return;
                }
                
                // 경로 위에 있는지 확인
                if (isOnPath(x, y)) {
                    alert('몬스터가 지나가는 길 위에는 영웅을 배치할 수 없습니다!');
                    return;
                }
                
                // 다른 영웅과 겹치는지 확인
                const minDistance = 50; // 최소 거리
                for (const hero of heroes) {
                    const dist = Math.sqrt((hero.x - x) ** 2 + (hero.y - y) ** 2);
                    if (dist < minDistance) {
                        alert('다른 영웅과 너무 가깝습니다!');
                        return;
                    }
                }
                
                const totalCards = getTotalHeroCards(placingHeroType);
                if (totalCards === 0 && (!heroStars[placingHeroType] || heroStars[placingHeroType] === 1)) {
                    alert('영웅 카드가 없습니다! 상점에서 소환하세요.');
                    return;
                }
                
                const hero = new Hero(x, y, placingHeroType);
                heroes.push(hero);
                placingHeroType = null;
                document.querySelectorAll('.hero-btn').forEach(btn => btn.classList.remove('selected'));
            } else {
                for (const hero of heroes) {
                    const dist = Math.sqrt((hero.x - x) ** 2 + (hero.y - y) ** 2);
                    if (dist < 20) {
                        selectedHero = hero;
                        break;
                    }
                }
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                if (gameState === 'MENU') {
                    startGame();
                } else if (gameState === 'PLAYING' && selectedHero) {
                    selectedHero.useSkill(enemies, effects);
                }
            } else if (e.key === 's' || e.key === 'S') {
                if (gameState === 'PLAYING') {
                    document.getElementById('shopModal').classList.toggle('show');
                }
            } else if (e.key === 'h' || e.key === 'H') {
                if (gameState === 'PLAYING') {
                    updateHeroCollection();
                    document.getElementById('heroManageModal').classList.toggle('show');
                }
            } else if (e.key === 'Escape') {
                document.getElementById('shopModal').classList.remove('show');
                document.getElementById('heroManageModal').classList.remove('show');
                document.getElementById('equipmentInventoryModal').classList.remove('show');
            } else if (e.key >= '1' && e.key <= '6') {
                const heroIndex = parseInt(e.key) - 1;
                placingHeroType = heroIndex;
                document.querySelectorAll('.hero-btn').forEach((btn, idx) => {
                    btn.classList.toggle('selected', idx === heroIndex);
                });
            }
        });

        document.getElementById('shopButton').addEventListener('click', () => {
            document.getElementById('shopModal').classList.toggle('show');
        });

        document.getElementById('heroManageButton').addEventListener('click', () => {
            updateHeroCollection();
            document.getElementById('heroManageModal').classList.toggle('show');
        });

        // 소비 아이템 초기화
        const consumableItems = [
            { name: '공격력 물약', costGold: 100, effect: 'attack+20%' },
            { name: '속도 감소 주문서', costGold: 150, effect: 'enemy_slow' },
            { name: '치유 물약', costGold: 200, effect: 'heal' },
            { name: '치명타 물약', costGold: 250, effect: 'crit+30%' },
            { name: '방어력 물약', costGold: 120, effect: 'defense+15%' }
        ];

        const consumableDiv = document.getElementById('consumableItems');
        consumableItems.forEach(item => {
            const div = document.createElement('div');
            div.className = 'shop-item';
            div.innerHTML = `
                <div class="item-name">${item.name}</div>
                <div class="item-cost">금화 ${item.costGold}</div>
            `;
            div.addEventListener('click', () => {
                if (gold >= item.costGold) {
                    gold -= item.costGold;
                    alert(`${item.name}을(를) 구매했습니다!`);
                    updateUI();
                } else {
                    alert('재화가 부족합니다!');
                }
            });
            consumableDiv.appendChild(div);
        });

        // 장비 아이템 초기화
        function initEquipmentShop() {
            const equipmentDiv = document.getElementById('equipmentItems');
            equipmentDiv.innerHTML = '';
            
            // 무기
            const weapons = Object.entries(equipmentDatabase).filter(([id, equip]) => equip.type === EquipmentType.WEAPON);
            weapons.forEach(([id, equip]) => {
                const div = document.createElement('div');
                div.className = 'shop-item';
                const costText = equip.costGold ? `금화 ${equip.costGold}` : `보물 ${equip.costTreasure}`;
                const statsText = [];
                if (equip.attack) statsText.push(`공격력 +${equip.attack}`);
                if (equip.attackSpeed) statsText.push(`공속 +${(equip.attackSpeed * 100).toFixed(0)}%`);
                if (equip.range) statsText.push(`범위 +${(equip.range * 100).toFixed(0)}%`);
                
                div.innerHTML = `
                    <div class="item-name">${equip.name}</div>
                    <div style="font-size: 14px; color: #87ceeb; margin: 5px 0;">${statsText.join(', ')}</div>
                    <div class="item-cost ${equip.costTreasure ? 'treasure' : ''}">${costText}</div>
                `;
                div.addEventListener('click', () => {
                    if (equip.costGold && gold >= equip.costGold) {
                        gold -= equip.costGold;
                        equipmentInventory[id] = (equipmentInventory[id] || 0) + 1;
                        alert(`${equip.name}을(를) 구매했습니다!`);
                        updateUI();
                    } else if (equip.costTreasure && treasure >= equip.costTreasure) {
                        treasure -= equip.costTreasure;
                        equipmentInventory[id] = (equipmentInventory[id] || 0) + 1;
                        alert(`${equip.name}을(를) 구매했습니다!`);
                        updateUI();
                    } else {
                        alert('재화가 부족합니다!');
                    }
                });
                equipmentDiv.appendChild(div);
            });
            
            // 갑옷
            const armors = Object.entries(equipmentDatabase).filter(([id, equip]) => equip.type === EquipmentType.ARMOR);
            armors.forEach(([id, equip]) => {
                const div = document.createElement('div');
                div.className = 'shop-item';
                const costText = equip.costGold ? `금화 ${equip.costGold}` : `보물 ${equip.costTreasure}`;
                const statsText = [];
                if (equip.health) statsText.push(`체력 +${equip.health}`);
                if (equip.defense) statsText.push(`방어력 +${(equip.defense * 100).toFixed(0)}%`);
                
                div.innerHTML = `
                    <div class="item-name">${equip.name}</div>
                    <div style="font-size: 14px; color: #87ceeb; margin: 5px 0;">${statsText.join(', ')}</div>
                    <div class="item-cost ${equip.costTreasure ? 'treasure' : ''}">${costText}</div>
                `;
                div.addEventListener('click', () => {
                    if (equip.costGold && gold >= equip.costGold) {
                        gold -= equip.costGold;
                        equipmentInventory[id] = (equipmentInventory[id] || 0) + 1;
                        alert(`${equip.name}을(를) 구매했습니다!`);
                        updateUI();
                    } else if (equip.costTreasure && treasure >= equip.costTreasure) {
                        treasure -= equip.costTreasure;
                        equipmentInventory[id] = (equipmentInventory[id] || 0) + 1;
                        alert(`${equip.name}을(를) 구매했습니다!`);
                        updateUI();
                    } else {
                        alert('재화가 부족합니다!');
                    }
                });
                equipmentDiv.appendChild(div);
            });
            
            // 투구
            const helmets = Object.entries(equipmentDatabase).filter(([id, equip]) => equip.type === EquipmentType.HELMET);
            helmets.forEach(([id, equip]) => {
                const div = document.createElement('div');
                div.className = 'shop-item';
                const costText = equip.costGold ? `금화 ${equip.costGold}` : `보물 ${equip.costTreasure}`;
                const statsText = [];
                if (equip.health) statsText.push(`체력 +${equip.health}`);
                if (equip.attackSpeed) statsText.push(`공속 +${(equip.attackSpeed * 100).toFixed(0)}%`);
                
                div.innerHTML = `
                    <div class="item-name">${equip.name}</div>
                    <div style="font-size: 14px; color: #87ceeb; margin: 5px 0;">${statsText.join(', ')}</div>
                    <div class="item-cost ${equip.costTreasure ? 'treasure' : ''}">${costText}</div>
                `;
                div.addEventListener('click', () => {
                    if (equip.costGold && gold >= equip.costGold) {
                        gold -= equip.costGold;
                        equipmentInventory[id] = (equipmentInventory[id] || 0) + 1;
                        alert(`${equip.name}을(를) 구매했습니다!`);
                        updateUI();
                    } else if (equip.costTreasure && treasure >= equip.costTreasure) {
                        treasure -= equip.costTreasure;
                        equipmentInventory[id] = (equipmentInventory[id] || 0) + 1;
                        alert(`${equip.name}을(를) 구매했습니다!`);
                        updateUI();
                    } else {
                        alert('재화가 부족합니다!');
                    }
                });
                equipmentDiv.appendChild(div);
            });
            
            // 장신구
            const accessories = Object.entries(equipmentDatabase).filter(([id, equip]) => equip.type === EquipmentType.ACCESSORY);
            accessories.forEach(([id, equip]) => {
                const div = document.createElement('div');
                div.className = 'shop-item';
                const costText = equip.costGold ? `금화 ${equip.costGold}` : `보물 ${equip.costTreasure}`;
                const statsText = [];
                if (equip.attack) statsText.push(`공격력 +${equip.attack}`);
                if (equip.attackSpeed) statsText.push(`공속 +${(equip.attackSpeed * 100).toFixed(0)}%`);
                if (equip.range) statsText.push(`범위 +${(equip.range * 100).toFixed(0)}%`);
                if (equip.critChance) statsText.push(`치명타 +${(equip.critChance * 100).toFixed(0)}%`);
                
                div.innerHTML = `
                    <div class="item-name">${equip.name}</div>
                    <div style="font-size: 14px; color: #87ceeb; margin: 5px 0;">${statsText.join(', ')}</div>
                    <div class="item-cost ${equip.costTreasure ? 'treasure' : ''}">${costText}</div>
                `;
                div.addEventListener('click', () => {
                    if (equip.costGold && gold >= equip.costGold) {
                        gold -= equip.costGold;
                        equipmentInventory[id] = (equipmentInventory[id] || 0) + 1;
                        alert(`${equip.name}을(를) 구매했습니다!`);
                        updateUI();
                    } else if (equip.costTreasure && treasure >= equip.costTreasure) {
                        treasure -= equip.costTreasure;
                        equipmentInventory[id] = (equipmentInventory[id] || 0) + 1;
                        alert(`${equip.name}을(를) 구매했습니다!`);
                        updateUI();
                    } else {
                        alert('재화가 부족합니다!');
                    }
                });
                equipmentDiv.appendChild(div);
            });
        }
        
        initEquipmentShop();

        // 초기 영웅 카드 지급 (튜토리얼용)
        addHeroCard(HeroType.LIUBEI, HeroGrade.R);
        addHeroCard(HeroType.ZHANGFEI, HeroGrade.SR);
        // 위(魏) 초기 영웅
        addHeroCard(HeroType.XUZHU, HeroGrade.R);
        addHeroCard(HeroType.XIAHOUDUN, HeroGrade.SR);
        // 촉(蜀) 초기 영웅
        addHeroCard(HeroType.WEIYAN, HeroGrade.R);
        addHeroCard(HeroType.HUANGZHONG, HeroGrade.SR);
        // 오(吳) 초기 영웅
        addHeroCard(HeroType.CHENGPU, HeroGrade.R);
        addHeroCard(HeroType.GANNING, HeroGrade.SR);
        // 위(魏) 초기 영웅
        addHeroCard(HeroType.XUZHU, HeroGrade.R);
        addHeroCard(HeroType.XIAHOUDUN, HeroGrade.SR);
        // 촉(蜀) 초기 영웅
        addHeroCard(HeroType.WEIYAN, HeroGrade.R);
        addHeroCard(HeroType.HUANGZHONG, HeroGrade.SR);
        // 오(吳) 초기 영웅
        addHeroCard(HeroType.CHENGPU, HeroGrade.R);
        addHeroCard(HeroType.GANNING, HeroGrade.SR);
        updateHeroSelection();

        // 게임 시작
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
